abase.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getCards(org.json.JSONArray)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.DeckPicker: void populateDeckList(java.lang.String)>
	4: <com.ichi2.anki.Deck: double getLastModified(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.AnkiDb: java.util.ArrayList queryColumn(java.lang.Class,java.lang.String,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: void deleteObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.Deck: void deleteCards(java.util.List)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact newFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,com.ichi2.anki.Model)>
	5: <com.ichi2.anki.FieldModel: void fromDb(com.ichi2.anki.Deck,long,java.util.TreeMap)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: boolean upgradeDeck()>
	6: <com.ichi2.anki.Deck: void updateFieldCache(long[])>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: void deleteObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: void deleteModels(org.json.JSONArray)>
	11: <com.ichi2.anki.Deck: void deleteModel(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact newFact()>
	4: <com.ichi2.anki.Model: com.ichi2.anki.Model getModel(com.ichi2.anki.Deck,long,boolean)>
	5: <com.ichi2.anki.Model: void loadFromDBPlusRelatedModels(com.ichi2.anki.Deck,long)>
	6: <com.ichi2.anki.Model: com.ichi2.anki.Model fromDb(com.ichi2.anki.Deck,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleModel(java.lang.Long)>
	12: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleFieldModels(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getMedia(org.json.JSONArray)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.CardEditor dummyMainMethod_com_ichi2_anki_CardEditor(android.content.Intent)>
	2: <com.ichi2.anki.CardEditor: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Card: com.ichi2.anki.Fact getFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,long)>
	5: <com.ichi2.anki.Fact: boolean fromDb(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: boolean upgradeDeck()>
	6: <com.ichi2.anki.Deck: int getInt(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask launchDeckTask(int,com.ichi2.anki.DeckTask$TaskListener,com.ichi2.anki.DeckTask$TaskData[])>
	4: <com.ichi2.anki.DeckTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackground(com.ichi2.anki.DeckTask$TaskData[])>
	6: <com.ichi2.anki.Deck: com.ichi2.anki.Card getCurrentCard()>
	7: <com.ichi2.anki.Deck: com.ichi2.anki.Card cardFromId(long)>
	8: <com.ichi2.anki.Card: boolean fromDB(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask launchDeckTask(int,com.ichi2.anki.DeckTask$TaskListener,com.ichi2.anki.DeckTask$TaskData[])>
	4: <com.ichi2.anki.DeckTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackground(com.ichi2.anki.DeckTask$TaskData[])>
	6: <com.ichi2.anki.Deck: void updateAllCards()>
	7: <com.ichi2.anki.Deck: long updateAllCardsFromPosition(long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Model: java.util.HashMap getModels(com.ichi2.anki.Deck)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: void rebuildCounts()>
	6: <com.ichi2.anki.AnkiDb: int queryScalar(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.Deck: void updateCardTags(long[])>
	10: <com.ichi2.anki.Deck: java.util.HashMap tagIds(java.lang.String[])>
	11: <com.ichi2.anki.Deck: java.util.HashMap tagIds(java.lang.String[],boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONObject getFacts(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONArray getFact(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: double getFloat(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleModel(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.DeckPicker: void populateDeckList(java.lang.String)>
	4: <java.lang.Thread: void run()>
	5: <com.ichi2.anki.DeckPicker: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Stats: com.ichi2.anki.Stats dailyStats(com.ichi2.anki.Deck)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask launchDeckTask(int,com.ichi2.anki.DeckTask$TaskListener,com.ichi2.anki.DeckTask$TaskData[])>
	4: <com.ichi2.anki.DeckTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackground(com.ichi2.anki.DeckTask$TaskData[])>
	6: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundUpdateFact(com.ichi2.anki.DeckTask$TaskData[])>
	7: <com.ichi2.anki.Fact: java.util.LinkedList getUpdatedRelatedCards()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleModel(java.lang.Long)>
	12: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleCardModels(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.CardEditor dummyMainMethod_com_ichi2_anki_CardEditor(android.content.Intent)>
	2: <com.ichi2.anki.CardEditor: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Card: com.ichi2.anki.Fact getFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,long)>
	5: <com.ichi2.anki.Fact: boolean fromDb(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleSources()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[])>
	10: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[],java.lang.String[])>
	11: <com.ichi2.anki.Deck: void updateAllPriorities(boolean,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact newFact()>
	4: <com.ichi2.anki.Model: com.ichi2.anki.Model getModel(com.ichi2.anki.Deck,long,boolean)>
	5: <com.ichi2.anki.CardModel: long modelIdFromDB(com.ichi2.anki.Deck,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleHistory()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Stats: com.ichi2.anki.Stats globalStats(com.ichi2.anki.Deck)>
	6: <com.ichi2.anki.Stats: void fromDB(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Stats: com.ichi2.anki.Stats globalStats(com.ichi2.anki.Deck)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void updateObjsFromKey(org.json.JSONObject,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: void updateModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: void mergeFieldModels(java.lang.String,org.json.JSONArray)>
	12: <com.ichi2.anki.Deck: void deleteFieldModel(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onPrepareOptionsMenu(android.view.Menu)>
	3: <com.ichi2.anki.Card: void loadTags()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: void initVars()>
	6: <com.ichi2.anki.Deck: boolean hasKey(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: void updatePriorities(long[])>
	6: <com.ichi2.anki.Deck: void updatePriorities(long[],java.lang.String[],boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void updateObjsFromKey(org.json.JSONObject,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: void updateModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: void mergeFieldModels(java.lang.String,org.json.JSONArray)>
	12: <com.ichi2.anki.Deck: void deleteFieldModel(java.lang.String,java.lang.String)>

Resource: android.database.Cursor
source method: _fillRevQueue()
source file: Deck.java
Our analysis output:
Soot started on Sun May 03 01:21:16 EDT 2020
Soot finished on Sun May 03 01:21:42 EDT 2020
Soot has run for 0 min. 25 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundMarkCard(com.ichi2.anki.DeckTask$TaskData[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundSuspendCard(com.ichi2.anki.DeckTask$TaskData[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.libanki.Collection: void close(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundMarkCard(com.ichi2.anki.DeckTask$TaskData[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundAnswerCard(com.ichi2.anki.DeckTask$TaskData[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.ISharedDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
SINK:
	<com.ichi2.anki.services.ISharedDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IPersonalDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
SINK:
	<com.ichi2.anki.services.IPersonalDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundAnswerCard(com.ichi2.anki.DeckTask$TaskData[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.Deck: long updateAllCardsFromPosition(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.ISharedDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
SINK:
	<com.ichi2.anki.services.ISharedDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IPersonalDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
SINK:
	<com.ichi2.anki.services.IPersonalDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.Deck: void updateFieldCache(long[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[])>
	10: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[],java.lang.String[])>
	11: <com.ichi2.anki.Deck: void updateAllPriorities(boolean,boolean)>
	12: <com.ichi2.anki.Deck: java.util.HashMap updateTagPriorities()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleDeck()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder$1: void onClick(android.view.View)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact addFact(com.ichi2.anki.Fact)>
	4: <com.ichi2.anki.Deck: java.util.TreeMap availableCardModels(com.ichi2.anki.Fact)>
	5: <com.ichi2.anki.CardModel: void fromDb(com.ichi2.anki.Deck,long,java.util.TreeMap)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.Deck: void updateCardTags(long[])>
	10: <com.ichi2.anki.Deck: java.util.HashMap splitTagsList(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
	6: <com.ichi2.anki.Deck: void setVar(java.lang.String,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.StudyOptions dummyMainMethod_com_ichi2_anki_StudyOptions(android.content.Intent)>
	2: <com.ichi2.anki.StudyOptions: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.StudyOptions: void showMoreOptionsDialog()>
	4: <com.ichi2.anki.Deck: boolean getPerDay()>
	5: <com.ichi2.anki.Deck: boolean getBool(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.DeckPicker: void populateDeckList(java.lang.String)>
	4: <java.lang.Thread: void run()>
	5: <com.ichi2.anki.DeckPicker: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONObject getFacts(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: void putFields(org.json.JSONArray,java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.CardEditor dummyMainMethod_com_ichi2_anki_CardEditor(android.content.Intent)>
	2: <com.ichi2.anki.CardEditor: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Card: com.ichi2.anki.Fact getFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,long)>
	5: <com.ichi2.anki.Fact: boolean fromDb(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getCards(org.json.JSONArray)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.DeckPicker: void populateDeckList(java.lang.String)>
	4: <com.ichi2.anki.Deck: double getLastModified(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.AnkiDb: java.util.ArrayList queryColumn(java.lang.Class,java.lang.String,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: void deleteObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.Deck: void deleteCards(java.util.List)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact newFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,com.ichi2.anki.Model)>
	5: <com.ichi2.anki.FieldModel: void fromDb(com.ichi2.anki.Deck,long,java.util.TreeMap)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: boolean upgradeDeck()>
	6: <com.ichi2.anki.Deck: void updateFieldCache(long[])>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: void deleteObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: void deleteModels(org.json.JSONArray)>
	11: <com.ichi2.anki.Deck: void deleteModel(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact newFact()>
	4: <com.ichi2.anki.Model: com.ichi2.anki.Model getModel(com.ichi2.anki.Deck,long,boolean)>
	5: <com.ichi2.anki.Model: void loadFromDBPlusRelatedModels(com.ichi2.anki.Deck,long)>
	6: <com.ichi2.anki.Model: com.ichi2.anki.Model fromDb(com.ichi2.anki.Deck,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleModel(java.lang.Long)>
	12: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleFieldModels(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getMedia(org.json.JSONArray)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.CardEditor dummyMainMethod_com_ichi2_anki_CardEditor(android.content.Intent)>
	2: <com.ichi2.anki.CardEditor: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Card: com.ichi2.anki.Fact getFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,long)>
	5: <com.ichi2.anki.Fact: boolean fromDb(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: boolean upgradeDeck()>
	6: <com.ichi2.anki.Deck: int getInt(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask launchDeckTask(int,com.ichi2.anki.DeckTask$TaskListener,com.ichi2.anki.DeckTask$TaskData[])>
	4: <com.ichi2.anki.DeckTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackground(com.ichi2.anki.DeckTask$TaskData[])>
	6: <com.ichi2.anki.Deck: com.ichi2.anki.Card getCurrentCard()>
	7: <com.ichi2.anki.Deck: com.ichi2.anki.Card cardFromId(long)>
	8: <com.ichi2.anki.Card: boolean fromDB(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask launchDeckTask(int,com.ichi2.anki.DeckTask$TaskListener,com.ichi2.anki.DeckTask$TaskData[])>
	4: <com.ichi2.anki.DeckTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackground(com.ichi2.anki.DeckTask$TaskData[])>
	6: <com.ichi2.anki.Deck: void updateAllCards()>
	7: <com.ichi2.anki.Deck: long updateAllCardsFromPosition(long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Model: java.util.HashMap getModels(com.ichi2.anki.Deck)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: void rebuildCounts()>
	6: <com.ichi2.anki.AnkiDb: int queryScalar(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.Deck: void updateCardTags(long[])>
	10: <com.ichi2.anki.Deck: java.util.HashMap tagIds(java.lang.String[])>
	11: <com.ichi2.anki.Deck: java.util.HashMap tagIds(java.lang.String[],boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONObject getFacts(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONArray getFact(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: double getFloat(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleModel(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.DeckPicker: void populateDeckList(java.lang.String)>
	4: <java.lang.Thread: void run()>
	5: <com.ichi2.anki.DeckPicker: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Stats: com.ichi2.anki.Stats dailyStats(com.ichi2.anki.Deck)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask launchDeckTask(int,com.ichi2.anki.DeckTask$TaskListener,com.ichi2.anki.DeckTask$TaskData[])>
	4: <com.ichi2.anki.DeckTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackground(com.ichi2.anki.DeckTask$TaskData[])>
	6: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundUpdateFact(com.ichi2.anki.DeckTask$TaskData[])>
	7: <com.ichi2.anki.Fact: java.util.LinkedList getUpdatedRelatedCards()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleModel(java.lang.Long)>
	12: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleCardModels(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.CardEditor dummyMainMethod_com_ichi2_anki_CardEditor(android.content.Intent)>
	2: <com.ichi2.anki.CardEditor: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Card: com.ichi2.anki.Fact getFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,long)>
	5: <com.ichi2.anki.Fact: boolean fromDb(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleSources()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[])>
	10: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[],java.lang.String[])>
	11: <com.ichi2.anki.Deck: void updateAllPriorities(boolean,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact newFact()>
	4: <com.ichi2.anki.Model: com.ichi2.anki.Model getModel(com.ichi2.anki.Deck,long,boolean)>
	5: <com.ichi2.anki.CardModel: long modelIdFromDB(com.ichi2.anki.Deck,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleHistory()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Stats: com.ichi2.anki.Stats globalStats(com.ichi2.anki.Deck)>
	6: <com.ichi2.anki.Stats: void fromDB(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Stats: com.ichi2.anki.Stats globalStats(com.ichi2.anki.Deck)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void updateObjsFromKey(org.json.JSONObject,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: void updateModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: void mergeFieldModels(java.lang.String,org.json.JSONArray)>
	12: <com.ichi2.anki.Deck: void deleteFieldModel(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onPrepareOptionsMenu(android.view.Menu)>
	3: <com.ichi2.anki.Card: void loadTags()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: void initVars()>
	6: <com.ichi2.anki.Deck: boolean hasKey(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: void updatePriorities(long[])>
	6: <com.ichi2.anki.Deck: void updatePriorities(long[],java.lang.String[],boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void updateObjsFromKey(org.json.JSONObject,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: void updateModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: void mergeFieldModels(java.lang.String,org.json.JSONArray)>
	12: <com.ichi2.anki.Deck: void deleteFieldModel(java.lang.String,java.lang.String)>

Resource: android.database.Cursor
source method: _fillNewQueue()
source file: Deck.java
Our analysis output:
Soot started on Sun May 03 01:21:57 EDT 2020
Soot finished on Sun May 03 01:22:22 EDT 2020
Soot has run for 0 min. 25 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundMarkCard(com.ichi2.anki.DeckTask$TaskData[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundSuspendCard(com.ichi2.anki.DeckTask$TaskData[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.libanki.Collection: void close(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundMarkCard(com.ichi2.anki.DeckTask$TaskData[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundAnswerCard(com.ichi2.anki.DeckTask$TaskData[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.ISharedDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
SINK:
	<com.ichi2.anki.services.ISharedDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IPersonalDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
SINK:
	<com.ichi2.anki.services.IPersonalDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.Deck: long updateAllCardsFromPosition(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.ISharedDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
SINK:
	<com.ichi2.anki.services.ISharedDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IPersonalDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
SINK:
	<com.ichi2.anki.services.IPersonalDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.Deck: void updateFieldCache(long[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[])>
	10: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[],java.lang.String[])>
	11: <com.ichi2.anki.Deck: void updateAllPriorities(boolean,boolean)>
	12: <com.ichi2.anki.Deck: java.util.HashMap updateTagPriorities()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleDeck()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder$1: void onClick(android.view.View)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact addFact(com.ichi2.anki.Fact)>
	4: <com.ichi2.anki.Deck: java.util.TreeMap availableCardModels(com.ichi2.anki.Fact)>
	5: <com.ichi2.anki.CardModel: void fromDb(com.ichi2.anki.Deck,long,java.util.TreeMap)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.Deck: void updateCardTags(long[])>
	10: <com.ichi2.anki.Deck: java.util.HashMap splitTagsList(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
	6: <com.ichi2.anki.Deck: void setVar(java.lang.String,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.StudyOptions dummyMainMethod_com_ichi2_anki_StudyOptions(android.content.Intent)>
	2: <com.ichi2.anki.StudyOptions: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.StudyOptions: void showMoreOptionsDialog()>
	4: <com.ichi2.anki.Deck: boolean getPerDay()>
	5: <com.ichi2.anki.Deck: boolean getBool(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.DeckPicker: void populateDeckList(java.lang.String)>
	4: <java.lang.Thread: void run()>
	5: <com.ichi2.anki.DeckPicker: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONObject getFacts(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: void putFields(org.json.JSONArray,java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.CardEditor dummyMainMethod_com_ichi2_anki_CardEditor(android.content.Intent)>
	2: <com.ichi2.anki.CardEditor: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Card: com.ichi2.anki.Fact getFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,long)>
	5: <com.ichi2.anki.Fact: boolean fromDb(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getCards(org.json.JSONArray)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.DeckPicker: void populateDeckList(java.lang.String)>
	4: <com.ichi2.anki.Deck: double getLastModified(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.AnkiDb: java.util.ArrayList queryColumn(java.lang.Class,java.lang.String,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: void deleteObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.Deck: void deleteCards(java.util.List)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact newFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,com.ichi2.anki.Model)>
	5: <com.ichi2.anki.FieldModel: void fromDb(com.ichi2.anki.Deck,long,java.util.TreeMap)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: boolean upgradeDeck()>
	6: <com.ichi2.anki.Deck: void updateFieldCache(long[])>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: void deleteObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: void deleteModels(org.json.JSONArray)>
	11: <com.ichi2.anki.Deck: void deleteModel(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact newFact()>
	4: <com.ichi2.anki.Model: com.ichi2.anki.Model getModel(com.ichi2.anki.Deck,long,boolean)>
	5: <com.ichi2.anki.Model: void loadFromDBPlusRelatedModels(com.ichi2.anki.Deck,long)>
	6: <com.ichi2.anki.Model: com.ichi2.anki.Model fromDb(com.ichi2.anki.Deck,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleModel(java.lang.Long)>
	12: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleFieldModels(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getMedia(org.json.JSONArray)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.CardEditor dummyMainMethod_com_ichi2_anki_CardEditor(android.content.Intent)>
	2: <com.ichi2.anki.CardEditor: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Card: com.ichi2.anki.Fact getFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,long)>
	5: <com.ichi2.anki.Fact: boolean fromDb(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: boolean upgradeDeck()>
	6: <com.ichi2.anki.Deck: int getInt(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask launchDeckTask(int,com.ichi2.anki.DeckTask$TaskListener,com.ichi2.anki.DeckTask$TaskData[])>
	4: <com.ichi2.anki.DeckTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackground(com.ichi2.anki.DeckTask$TaskData[])>
	6: <com.ichi2.anki.Deck: com.ichi2.anki.Card getCurrentCard()>
	7: <com.ichi2.anki.Deck: com.ichi2.anki.Card cardFromId(long)>
	8: <com.ichi2.anki.Card: boolean fromDB(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask launchDeckTask(int,com.ichi2.anki.DeckTask$TaskListener,com.ichi2.anki.DeckTask$TaskData[])>
	4: <com.ichi2.anki.DeckTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackground(com.ichi2.anki.DeckTask$TaskData[])>
	6: <com.ichi2.anki.Deck: void updateAllCards()>
	7: <com.ichi2.anki.Deck: long updateAllCardsFromPosition(long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Model: java.util.HashMap getModels(com.ichi2.anki.Deck)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: void rebuildCounts()>
	6: <com.ichi2.anki.AnkiDb: int queryScalar(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.Deck: void updateCardTags(long[])>
	10: <com.ichi2.anki.Deck: java.util.HashMap tagIds(java.lang.String[])>
	11: <com.ichi2.anki.Deck: java.util.HashMap tagIds(java.lang.String[],boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONObject getFacts(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONArray getFact(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: double getFloat(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleModel(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.DeckPicker: void populateDeckList(java.lang.String)>
	4: <java.lang.Thread: void run()>
	5: <com.ichi2.anki.DeckPicker: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Stats: com.ichi2.anki.Stats dailyStats(com.ichi2.anki.Deck)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask launchDeckTask(int,com.ichi2.anki.DeckTask$TaskListener,com.ichi2.anki.DeckTask$TaskData[])>
	4: <com.ichi2.anki.DeckTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackground(com.ichi2.anki.DeckTask$TaskData[])>
	6: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundUpdateFact(com.ichi2.anki.DeckTask$TaskData[])>
	7: <com.ichi2.anki.Fact: java.util.LinkedList getUpdatedRelatedCards()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleModel(java.lang.Long)>
	12: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleCardModels(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.CardEditor dummyMainMethod_com_ichi2_anki_CardEditor(android.content.Intent)>
	2: <com.ichi2.anki.CardEditor: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Card: com.ichi2.anki.Fact getFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,long)>
	5: <com.ichi2.anki.Fact: boolean fromDb(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleSources()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[])>
	10: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[],java.lang.String[])>
	11: <com.ichi2.anki.Deck: void updateAllPriorities(boolean,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact newFact()>
	4: <com.ichi2.anki.Model: com.ichi2.anki.Model getModel(com.ichi2.anki.Deck,long,boolean)>
	5: <com.ichi2.anki.CardModel: long modelIdFromDB(com.ichi2.anki.Deck,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleHistory()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Stats: com.ichi2.anki.Stats globalStats(com.ichi2.anki.Deck)>
	6: <com.ichi2.anki.Stats: void fromDB(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Stats: com.ichi2.anki.Stats globalStats(com.ichi2.anki.Deck)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void updateObjsFromKey(org.json.JSONObject,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: void updateModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: void mergeFieldModels(java.lang.String,org.json.JSONArray)>
	12: <com.ichi2.anki.Deck: void deleteFieldModel(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onPrepareOptionsMenu(android.view.Menu)>
	3: <com.ichi2.anki.Card: void loadTags()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: void initVars()>
	6: <com.ichi2.anki.Deck: boolean hasKey(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: void updatePriorities(long[])>
	6: <com.ichi2.anki.Deck: void updatePriorities(long[],java.lang.String[],boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void updateObjsFromKey(org.json.JSONObject,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: void updateModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: void mergeFieldModels(java.lang.String,org.json.JSONArray)>
	12: <com.ichi2.anki.Deck: void deleteFieldModel(java.lang.String,java.lang.String)>

Resource: android.database.Cursor
source method: _fillCramQueue()
source file: Deck.java
Our analysis output:
Soot started on Sun May 03 01:22:38 EDT 2020
Soot finished on Sun May 03 01:23:03 EDT 2020
Soot has run for 0 min. 25 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundMarkCard(com.ichi2.anki.DeckTask$TaskData[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundSuspendCard(com.ichi2.anki.DeckTask$TaskData[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.libanki.Collection: void close(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundMarkCard(com.ichi2.anki.DeckTask$TaskData[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundAnswerCard(com.ichi2.anki.DeckTask$TaskData[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.ISharedDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
SINK:
	<com.ichi2.anki.services.ISharedDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IPersonalDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
SINK:
	<com.ichi2.anki.services.IPersonalDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getPersonalDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.Deck: long updateAllCardsFromPosition(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: java.util.List getSharedDeckDownloads()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void downloadFile(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.ISharedDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
SINK:
	<com.ichi2.anki.services.ISharedDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerSharedDeckCallback(com.ichi2.anki.services.ISharedDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void unregisterPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IPersonalDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
SINK:
	<com.ichi2.anki.services.IPersonalDeckServiceCallback$Stub$Proxy: void publishProgress(java.util.List)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void resumeDownloadUpdating(com.ichi2.anki.Download)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.AnkiDb: void <init>(java.lang.String)>
SINK:
	<com.ichi2.anki.Deck: void updateFieldCache(long[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
SINK:
	<com.ichi2.anki.services.IDownloadManagerService$Stub$Proxy: void registerPersonalDeckCallback(com.ichi2.anki.services.IPersonalDeckServiceCallback)>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[])>
	10: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[],java.lang.String[])>
	11: <com.ichi2.anki.Deck: void updateAllPriorities(boolean,boolean)>
	12: <com.ichi2.anki.Deck: java.util.HashMap updateTagPriorities()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleDeck()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder$1: void onClick(android.view.View)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact addFact(com.ichi2.anki.Fact)>
	4: <com.ichi2.anki.Deck: java.util.TreeMap availableCardModels(com.ichi2.anki.Fact)>
	5: <com.ichi2.anki.CardModel: void fromDb(com.ichi2.anki.Deck,long,java.util.TreeMap)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.Deck: void updateCardTags(long[])>
	10: <com.ichi2.anki.Deck: java.util.HashMap splitTagsList(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
	6: <com.ichi2.anki.Deck: void setVar(java.lang.String,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.StudyOptions dummyMainMethod_com_ichi2_anki_StudyOptions(android.content.Intent)>
	2: <com.ichi2.anki.StudyOptions: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.StudyOptions: void showMoreOptionsDialog()>
	4: <com.ichi2.anki.Deck: boolean getPerDay()>
	5: <com.ichi2.anki.Deck: boolean getBool(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.DeckPicker: void populateDeckList(java.lang.String)>
	4: <java.lang.Thread: void run()>
	5: <com.ichi2.anki.DeckPicker: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONObject getFacts(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: void putFields(org.json.JSONArray,java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.CardEditor dummyMainMethod_com_ichi2_anki_CardEditor(android.content.Intent)>
	2: <com.ichi2.anki.CardEditor: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Card: com.ichi2.anki.Fact getFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,long)>
	5: <com.ichi2.anki.Fact: boolean fromDb(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getCards(org.json.JSONArray)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.DeckPicker: void populateDeckList(java.lang.String)>
	4: <com.ichi2.anki.Deck: double getLastModified(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.AnkiDb: java.util.ArrayList queryColumn(java.lang.Class,java.lang.String,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: void deleteObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.Deck: void deleteCards(java.util.List)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact newFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,com.ichi2.anki.Model)>
	5: <com.ichi2.anki.FieldModel: void fromDb(com.ichi2.anki.Deck,long,java.util.TreeMap)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: boolean upgradeDeck()>
	6: <com.ichi2.anki.Deck: void updateFieldCache(long[])>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: void deleteObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: void deleteModels(org.json.JSONArray)>
	11: <com.ichi2.anki.Deck: void deleteModel(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact newFact()>
	4: <com.ichi2.anki.Model: com.ichi2.anki.Model getModel(com.ichi2.anki.Deck,long,boolean)>
	5: <com.ichi2.anki.Model: void loadFromDBPlusRelatedModels(com.ichi2.anki.Deck,long)>
	6: <com.ichi2.anki.Model: com.ichi2.anki.Model fromDb(com.ichi2.anki.Deck,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleModel(java.lang.Long)>
	12: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleFieldModels(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getMedia(org.json.JSONArray)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.CardEditor dummyMainMethod_com_ichi2_anki_CardEditor(android.content.Intent)>
	2: <com.ichi2.anki.CardEditor: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Card: com.ichi2.anki.Fact getFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,long)>
	5: <com.ichi2.anki.Fact: boolean fromDb(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: boolean upgradeDeck()>
	6: <com.ichi2.anki.Deck: int getInt(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask launchDeckTask(int,com.ichi2.anki.DeckTask$TaskListener,com.ichi2.anki.DeckTask$TaskData[])>
	4: <com.ichi2.anki.DeckTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackground(com.ichi2.anki.DeckTask$TaskData[])>
	6: <com.ichi2.anki.Deck: com.ichi2.anki.Card getCurrentCard()>
	7: <com.ichi2.anki.Deck: com.ichi2.anki.Card cardFromId(long)>
	8: <com.ichi2.anki.Card: boolean fromDB(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask launchDeckTask(int,com.ichi2.anki.DeckTask$TaskListener,com.ichi2.anki.DeckTask$TaskData[])>
	4: <com.ichi2.anki.DeckTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackground(com.ichi2.anki.DeckTask$TaskData[])>
	6: <com.ichi2.anki.Deck: void updateAllCards()>
	7: <com.ichi2.anki.Deck: long updateAllCardsFromPosition(long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Model: java.util.HashMap getModels(com.ichi2.anki.Deck)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: void rebuildCounts()>
	6: <com.ichi2.anki.AnkiDb: int queryScalar(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.Deck: void updateCardTags(long[])>
	10: <com.ichi2.anki.Deck: java.util.HashMap tagIds(java.lang.String[])>
	11: <com.ichi2.anki.Deck: java.util.HashMap tagIds(java.lang.String[],boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONObject getFacts(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONArray getFact(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: double getFloat(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleModel(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.DeckPicker: void populateDeckList(java.lang.String)>
	4: <java.lang.Thread: void run()>
	5: <com.ichi2.anki.DeckPicker: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Stats: com.ichi2.anki.Stats dailyStats(com.ichi2.anki.Deck)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask launchDeckTask(int,com.ichi2.anki.DeckTask$TaskListener,com.ichi2.anki.DeckTask$TaskData[])>
	4: <com.ichi2.anki.DeckTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackground(com.ichi2.anki.DeckTask$TaskData[])>
	6: <com.ichi2.anki.DeckTask: com.ichi2.anki.DeckTask$TaskData doInBackgroundUpdateFact(com.ichi2.anki.DeckTask$TaskData[])>
	7: <com.ichi2.anki.Fact: java.util.LinkedList getUpdatedRelatedCards()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: java.lang.Object getObjsFromKey(org.json.JSONArray,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: org.json.JSONArray getModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: org.json.JSONObject bundleModel(java.lang.Long)>
	12: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleCardModels(java.lang.Long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.CardEditor dummyMainMethod_com_ichi2_anki_CardEditor(android.content.Intent)>
	2: <com.ichi2.anki.CardEditor: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Card: com.ichi2.anki.Fact getFact()>
	4: <com.ichi2.anki.Fact: void <init>(com.ichi2.anki.Deck,long)>
	5: <com.ichi2.anki.Fact: boolean fromDb(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleSources()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[])>
	10: <com.ichi2.anki.SyncClient: void rebuildPriorities(long[],java.lang.String[])>
	11: <com.ichi2.anki.Deck: void updateAllPriorities(boolean,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.FactAdder dummyMainMethod_com_ichi2_anki_FactAdder(android.content.Intent)>
	2: <com.ichi2.anki.FactAdder: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.Deck: com.ichi2.anki.Fact newFact()>
	4: <com.ichi2.anki.Model: com.ichi2.anki.Model getModel(com.ichi2.anki.Deck,long,boolean)>
	5: <com.ichi2.anki.CardModel: long modelIdFromDB(com.ichi2.anki.Deck,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONArray summaries()>
	9: <com.ichi2.anki.SyncClient: org.json.JSONObject summary(double)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeck(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: org.json.JSONObject genPayload(org.json.JSONArray)>
	9: <com.ichi2.anki.SyncClient: org.json.JSONArray bundleHistory()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Stats: com.ichi2.anki.Stats globalStats(com.ichi2.anki.Deck)>
	6: <com.ichi2.anki.Stats: void fromDB(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Stats: com.ichi2.anki.Stats globalStats(com.ichi2.anki.Deck)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void updateObjsFromKey(org.json.JSONObject,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: void updateModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: void mergeFieldModels(java.lang.String,org.json.JSONArray)>
	12: <com.ichi2.anki.Deck: void deleteFieldModel(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ichi2.anki.AnkiDroidApp: void onCreate()>
	2: <com.ichi2.anki.DeckPreferences$DeckPreferenceHack$Editor: boolean commit()>
	3: <com.ichi2.anki.Deck: void setNewCardsPerDay(int)>
	4: <com.ichi2.anki.Deck: void reset()>
	5: <com.ichi2.anki.Deck: java.lang.String rebuildCSS()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onPrepareOptionsMenu(android.view.Menu)>
	3: <com.ichi2.anki.Card: void loadTags()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: void initVars()>
	6: <com.ichi2.anki.Deck: boolean hasKey(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
	5: <com.ichi2.anki.Deck: void updatePriorities(long[])>
	6: <com.ichi2.anki.Deck: void updatePriorities(long[],java.lang.String[],boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.AnkiDroidWidget$UpdateService dummyMainMethod_com_ichi2_anki_AnkiDroidWidget$UpdateService(android.content.Intent)>
	2: <com.ichi2.anki.AnkiDroidWidget$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.anki.AnkiDroidWidget$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context)>
	4: <com.ichi2.anki.Deck: com.ichi2.anki.Deck openDeck(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker$4: void onClick(android.view.View)>
	3: <com.ichi2.async.Connection: com.ichi2.async.Connection syncAllDecks(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	4: <com.ichi2.async.Connection: com.ichi2.async.Connection launchConnectionTask(com.ichi2.async.Connection$TaskListener,com.ichi2.async.Connection$Payload)>
	5: <com.ichi2.async.Connection: java.lang.Object doInBackground(java.lang.Object[])>
	6: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackground(com.ichi2.async.Connection$Payload[])>
	7: <com.ichi2.async.Connection: com.ichi2.async.Connection$Payload doInBackgroundSyncDeckFromPayload(com.ichi2.async.Connection$Payload)>
	8: <com.ichi2.anki.SyncClient: void applyPayloadReply(org.json.JSONObject)>
	9: <com.ichi2.anki.SyncClient: void updateObjsFromKey(org.json.JSONObject,java.lang.String)>
	10: <com.ichi2.anki.SyncClient: void updateModels(org.json.JSONArray)>
	11: <com.ichi2.anki.SyncClient: void mergeFieldModels(java.lang.String,org.json.JSONArray)>
	12: <com.ichi2.anki.Deck: void deleteFieldModel(java.lang.String,java.lang.String)>

File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-eca3100494.apk
File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-eca3100494.apk
File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-48c627368c.apk
File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-48c627368c.apk
File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-126a6fdb67.apk
File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-48c627368c.apk
File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-cfe6d83f85.apk
File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-cfe6d83f85.apk
File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-cfe6d83f85.apk
File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-e87690da8f.apk
Resource: android.database.Cursor
source method: upgradeDB() @line 91
source file: MetaDB.java
Our analysis output:
Soot started on Sun May 03 01:23:19 EDT 2020
Soot finished on Sun May 03 01:23:44 EDT 2020
Soot has run for 0 min. 25 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.provider.CardContentProvider dummyMainMethod_com_ichi2_anki_provider_CardContentProvider(android.content.Intent)>
	2: <com.ichi2.anki.provider.CardContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.ModelFieldEditor dummyMainMethod_com_ichi2_anki_ModelFieldEditor(android.content.Intent)>
	2: <com.ichi2.anki.ModelFieldEditor: void onStop()>
	3: <com.ichi2.widget.WidgetStatus: void update(android.content.Context)>
	4: <com.ichi2.anki.stats.AnkiStatsTaskHandler$CreateFirstStatisticChooserTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.stats.AnkiStatsTaskHandler$CreateFirstStatisticChooserTask: java.lang.Integer doInBackground(java.lang.Object[])>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.provider.CardContentProvider dummyMainMethod_com_ichi2_anki_provider_CardContentProvider(android.content.Intent)>
	2: <com.ichi2.anki.provider.CardContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onKeyUp(int,android.view.KeyEvent)>
	3: <com.ichi2.anki.AbstractFlashcardViewer: void playSounds(boolean)>
	4: <com.ichi2.anki.AbstractFlashcardViewer: void readCardText(com.ichi2.libanki.Card,int)>
	5: <com.ichi2.anki.ReadText: void textToSpeech(java.lang.String,long,int,int)>
	6: <com.ichi2.anki.ReadText: java.lang.String getLanguage(long,int,int)>
	7: <com.ichi2.anki.MetaDB: java.lang.String getLanguage(android.content.Context,long,int,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.ModelFieldEditor dummyMainMethod_com_ichi2_anki_ModelFieldEditor(android.content.Intent)>
	2: <com.ichi2.anki.ModelFieldEditor: void onStop()>
	3: <com.ichi2.widget.WidgetStatus: void update(android.content.Context)>
	4: <com.ichi2.anki.stats.AnkiStatsTaskHandler$CreateSmallTodayOverview: java.lang.Object doInBackground(java.lang.Object[])>
	5: <com.ichi2.anki.stats.AnkiStatsTaskHandler$CreateSmallTodayOverview: java.lang.String doInBackground(java.lang.Object[])>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: void onRequestPermissionsResult(int,java.lang.String[],int[])>
	3: <com.ichi2.anki.DeckPicker: void showStartupScreensAndDialogs(android.content.SharedPreferences,int)>
	4: <com.ichi2.anki.DeckPicker: void onFinishedStartup()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.widget.AnkiDroidWidgetSmall$UpdateService dummyMainMethod_com_ichi2_widget_AnkiDroidWidgetSmall$UpdateService(android.content.Intent)>
	2: <com.ichi2.widget.AnkiDroidWidgetSmall$UpdateService: void onStart(android.content.Intent,int)>
	3: <com.ichi2.widget.AnkiDroidWidgetSmall$UpdateService: android.widget.RemoteViews buildUpdate(android.content.Context,boolean)>
	4: <com.ichi2.widget.WidgetStatus: int[] fetchSmall(android.content.Context)>
	5: <com.ichi2.anki.MetaDB: int[] getWidgetSmallStatus(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.IntentHandler dummyMainMethod_com_ichi2_anki_IntentHandler(android.content.Intent)>
	2: <com.ichi2.anki.IntentHandler: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.IntentHandler: void sendShowImportFileDialogMsg(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.Reviewer dummyMainMethod_com_ichi2_anki_Reviewer(android.content.Intent)>
	2: <com.ichi2.anki.Reviewer: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.Reviewer: void setWhiteboardEnabledState(boolean)>
	4: <com.ichi2.anki.MetaDB: void storeWhiteboardState(android.content.Context,long,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.services.NotificationService dummyMainMethod_com_ichi2_anki_services_NotificationService(android.content.Intent)>
	2: <com.ichi2.anki.services.NotificationService: int onStartCommand(android.content.Intent,int,int)>
	3: <com.ichi2.widget.WidgetStatus: int fetchDue(android.content.Context)>
	4: <com.ichi2.anki.MetaDB: int getNotificationStatus(android.content.Context)>
	5: <com.ichi2.anki.MetaDB: void openDBIfClosed(android.content.Context)>
	6: <com.ichi2.anki.MetaDB: void openDB(android.content.Context)>
	7: <com.ichi2.anki.MetaDB: android.database.sqlite.SQLiteDatabase upgradeDB(android.database.sqlite.SQLiteDatabase,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckPicker: void showDatabaseErrorDialog(int)>
	4: <com.ichi2.anki.AnkiActivity: void showAsyncDialogFragment(com.ichi2.anki.dialogs.AsyncDialogFragment)>
	5: <com.ichi2.anki.dialogs.SyncErrorDialog: android.os.Message getDialogHandlerMessage()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.services.NotificationService dummyMainMethod_com_ichi2_anki_services_NotificationService(android.content.Intent)>
	2: <com.ichi2.anki.services.NotificationService: int onStartCommand(android.content.Intent,int,int)>
	3: <com.ichi2.widget.WidgetStatus: int fetchDue(android.content.Context)>
	4: <com.ichi2.anki.MetaDB: int getNotificationStatus(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.IntentHandler dummyMainMethod_com_ichi2_anki_IntentHandler(android.content.Intent)>
	2: <com.ichi2.anki.IntentHandler: void onCreate(android.os.Bundle)>
	3: <com.ichi2.anki.IntentHandler: void sendDoSyncMsg()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckPicker: void showDatabaseErrorDialog(int)>
	4: <com.ichi2.anki.AnkiActivity: void showAsyncDialogFragment(com.ichi2.anki.dialogs.AsyncDialogFragment)>
	5: <com.ichi2.anki.dialogs.MediaCheckDialog: android.os.Message getDialogHandlerMessage()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckPicker: void showDatabaseErrorDialog(int)>
	4: <com.ichi2.anki.AnkiActivity: void showAsyncDialogFragment(com.ichi2.anki.dialogs.AsyncDialogFragment)>
	5: <com.ichi2.anki.dialogs.DatabaseErrorDialog: android.os.Message getDialogHandlerMessage()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ichi2.anki.DeckPicker dummyMainMethod_com_ichi2_anki_DeckPicker(android.content.Intent)>
	2: <com.ichi2.anki.DeckPicker: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.ichi2.anki.DeckPicker: void showDatabaseErrorDialog(int)>
	4: <com.ichi2.anki.AnkiActivity: void showAsyncDialogFragment(com.ichi2.anki.dialogs.AsyncDialogFragment)>
	5: <com.ichi2.anki.dialogs.DeckPickerExportCompleteDialog: android.os.Message getDialogHandlerMessage()>

Resource: android.database.Cursor
source method: addWords()
source file: ContactsDictionary.java
Our analysis output:
Soot started on Sun May 03 01:24:05 EDT 2020
Soot finished on Sun May 03 01:24:10 EDT 2020
Soot has run for 0 min. 5 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.menny.android.anysoftkeyboard.SoftKeyboard dummyMainMethod_com_menny_android_anysoftkeyboard_SoftKeyboard(android.content.Intent)>
	2: <com.menny.android.anysoftkeyboard.AnySoftKeyboard: void onCreate()>
	3: <com.menny.android.anysoftkeyboard.AnySoftKeyboard: void initSuggest()>
	4: <com.menny.android.anysoftkeyboard.dictionary.DictionaryFactory: com.menny.android.anysoftkeyboard.dictionary.UserDictionaryBase createUserDictionary(com.menny.android.anysoftkeyboard.AnyKeyboardContextProvider)>
	5: <com.menny.android.anysoftkeyboard.dictionary.UserDictionaryBase: void loadDictionary()>
	6: <com.menny.android.anysoftkeyboard.dictionary.SQLiteUserDictionaryBase: void loadAllWords()>
	7: <com.menny.android.anysoftkeyboard.dictionary.DictionarySQLiteConnection: java.util.List getAllWords()>

File does not exist: ./DroidLeaks/apps/AnySoftKeyboard-rev-6f539583a8.apk
Resource: android.database.Cursor
source method: doInBackground()
source file: UserDictionaryEditorActivity.java
Our analysis output:
Soot started on Sun May 03 01:24:14 EDT 2020
Soot finished on Sun May 03 01:24:20 EDT 2020
Soot has run for 0 min. 6 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: android.database.Cursor
source method: indexCachedResources()
source file: HillshadeLayer.java
Our analysis output:
Soot started on Sun May 03 01:24:26 EDT 2020
Soot finished on Sun May 03 01:25:08 EDT 2020
Soot has run for 0 min. 41 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<net.osmand.plus.audionotes.SettingsAudioVideoActivity: android.hardware.Camera openCamera()>
SINK:
	<net.osmand.plus.audionotes.SettingsAudioVideoActivity: void onCreate(android.os.Bundle)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<net.osmand.plus.audionotes.AudioVideoNotesPlugin: android.hardware.Camera openCamera()>
SINK:
	<net.osmand.plus.audionotes.AudioVideoNotesPlugin: void takePhotoWithCamera(double,double,net.osmand.plus.activities.MapActivity,android.hardware.Camera)>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivity: void onResume()>
	3: <net.osmand.plus.activities.MapActivity: void showAndHideMapPosition()>
	4: <net.osmand.plus.OsmandApplication: void runMessageInUIThreadAndCancelPrevious(int,java.lang.Runnable,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.search.SearchStreetByNameActivity dummyMainMethod_net_osmand_plus_activities_search_SearchStreetByNameActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.search.SearchByNameAbstractActivity: void onCreate(android.os.Bundle)>
	3: <net.osmand.plus.srtmplugin.HillshadeLayer$1: java.lang.Object doInBackground(java.lang.Object[])>
	4: <net.osmand.plus.srtmplugin.HillshadeLayer$1: java.lang.Void doInBackground(java.lang.Void[])>
	5: <net.osmand.plus.srtmplugin.HillshadeLayer$1: void indexCachedResources(java.util.Map,java.util.Map)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.media.AudioManager: int requestAudioFocus(android.media.AudioManager$OnAudioFocusChangeListener,int,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.resources.ResourceManager: void <init>(net.osmand.plus.OsmandApplication)>
	3: <net.osmand.plus.resources.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.OsmAndLocationProvider$4: void run()>
	5: <net.osmand.plus.routing.VoiceRouter: void gpsLocationLost()>
	6: <net.osmand.plus.voice.CommandBuilder: void play()>
	7: <net.osmand.plus.voice.MediaCommandPlayerImpl: void playCommands(net.osmand.plus.voice.CommandBuilder)>
	8: <net.osmand.plus.voice.AbstractPrologCommandPlayer: void requestAudioFocus()>
	9: <net.osmand.plus.api.AudioFocusHelperImpl: boolean requestFocus(net.osmand.plus.ClientContext,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.search.SearchStreetByNameActivity dummyMainMethod_net_osmand_plus_activities_search_SearchStreetByNameActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.search.SearchByNameAbstractActivity: void onCreate(android.os.Bundle)>
	3: <net.osmand.plus.download.DownloadIndexesThread$DownloadIndexesAsyncTask: java.lang.Object doInBackground(java.lang.Object[])>
	4: <net.osmand.plus.download.DownloadIndexesThread$DownloadIndexesAsyncTask: java.lang.String doInBackground(net.osmand.plus.download.IndexItem[])>
	5: <net.osmand.plus.download.DownloadIndexesThread$DownloadIndexesAsyncTask: java.lang.String reindexFiles(java.util.List)>
	6: <net.osmand.plus.resources.ResourceManager: java.util.List indexingMaps(net.osmand.IProgress)>
	7: <net.osmand.plus.base.BasicProgressAsyncTask: void startTask(java.lang.String,int)>
	8: <net.osmand.plus.base.BasicProgressAsyncTask: void updProgress(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.search.SearchStreetByNameActivity dummyMainMethod_net_osmand_plus_activities_search_SearchStreetByNameActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.search.SearchByNameAbstractActivity: void onCreate(android.os.Bundle)>
	3: <net.osmand.plus.osmedit.OsmBugsLayer$3: java.lang.Object doInBackground(java.lang.Object[])>
	4: <net.osmand.plus.osmedit.OsmBugsLayer$3: java.lang.String doInBackground(java.lang.Void[])>
	5: <net.osmand.plus.osmedit.OsmBugsLocalUtil: java.lang.String createNewBug(double,double,java.lang.String)>
	6: <net.osmand.plus.osmedit.OsmBugsDbHelper: long getMinID()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.resources.ResourceManager: void <init>(net.osmand.plus.OsmandApplication)>
	3: <net.osmand.plus.resources.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.views.OsmandMapTileView$2: void run()>
	5: <net.osmand.plus.views.OsmandMapTileView: void access$800(net.osmand.plus.views.OsmandMapTileView,net.osmand.plus.views.OsmandMapLayer$DrawSettings)>
	6: <net.osmand.plus.views.OsmandMapTileView: void refreshMapInternal(net.osmand.plus.views.OsmandMapLayer$DrawSettings)>
	7: <net.osmand.plus.views.OsmandMapTileView: void drawOverMap(android.graphics.Canvas,net.osmand.data.RotatedTileBox,net.osmand.plus.views.OsmandMapLayer$DrawSettings)>
	8: <net.osmand.plus.views.MapControlsLayer: void onDraw(android.graphics.Canvas,net.osmand.data.RotatedTileBox,net.osmand.plus.views.OsmandMapLayer$DrawSettings)>
	9: <net.osmand.plus.views.MapControlsLayer: void hideZoomLevelInTime()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.sqlite.SQLiteDatabase openDatabase(java.lang.String,android.database.sqlite.SQLiteDatabase$CursorFactory,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.resources.ResourceManager: void <init>(net.osmand.plus.OsmandApplication)>
	3: <net.osmand.plus.resources.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.resources.ResourceManager: android.graphics.Bitmap getRequestedImageTile(net.osmand.plus.resources.AsyncLoadingThread$TileLoadDownloadRequest)>
	5: <net.osmand.plus.SQLiteTileSource: android.graphics.Bitmap getImage(int,int,int,long[])>
	6: <net.osmand.plus.SQLiteTileSource: net.osmand.plus.api.SQLiteAPI$SQLiteConnection getDatabase()>
	7: <net.osmand.plus.api.SQLiteAPIImpl: net.osmand.plus.api.SQLiteAPI$SQLiteConnection openByAbsolutePath(java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.search.SearchStreetByNameActivity dummyMainMethod_net_osmand_plus_activities_search_SearchStreetByNameActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.search.SearchByNameAbstractActivity: void onCreate(android.os.Bundle)>
	3: <net.osmand.plus.osmedit.EditingPOIActivity$18: java.lang.Object doInBackground(java.lang.Object[])>
	4: <net.osmand.plus.osmedit.EditingPOIActivity$18: net.osmand.osm.edit.Node doInBackground(java.lang.Void[])>
	5: <net.osmand.plus.osmedit.OpenstreetmapLocalUtil: net.osmand.osm.edit.Node commitNodeImpl(net.osmand.plus.osmedit.OsmPoint$Action,net.osmand.osm.edit.Node,net.osmand.osm.edit.EntityInfo,java.lang.String,boolean)>
	6: <net.osmand.plus.osmedit.OpenstreetmapsDbHelper: long getMinID()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.osmedit.LocalOpenstreetmapActivity dummyMainMethod_net_osmand_plus_osmedit_LocalOpenstreetmapActivity(android.content.Intent)>
	2: <net.osmand.plus.osmedit.LocalOpenstreetmapActivity: void onResume()>
	3: <net.osmand.plus.osmedit.OpenstreetmapsDbHelper: java.util.List getOpenstreetmapPoints()>
	4: <net.osmand.plus.osmedit.OpenstreetmapsDbHelper: java.util.List checkOpenstreetmapPoints()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.FavouritesActivity dummyMainMethod_net_osmand_plus_activities_FavouritesActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.FavouritesActivity: void onCreate(android.os.Bundle)>
	3: <net.osmand.plus.FavouritesDbHelper: java.util.Map getFavoriteGroups()>
	4: <net.osmand.plus.FavouritesDbHelper: void checkFavoritePoints()>
	5: <net.osmand.plus.api.SQLiteAPIImpl$SQLiteDatabaseWrapper: net.osmand.plus.api.SQLiteAPI$SQLiteCursor rawQuery(java.lang.String,java.lang.String[])>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.resources.ResourceManager: void <init>(net.osmand.plus.OsmandApplication)>
	3: <net.osmand.plus.resources.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.OsmandApplication$6: void run()>
	5: <net.osmand.plus.OsmandApplication: void access$300(net.osmand.plus.OsmandApplication)>
	6: <net.osmand.plus.OsmandApplication: void startApplicationBackground()>
	7: <net.osmand.plus.activities.SavingTrackHelper: boolean hasDataToSave()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.osmedit.LocalOpenstreetmapActivity dummyMainMethod_net_osmand_plus_osmedit_LocalOpenstreetmapActivity(android.content.Intent)>
	2: <net.osmand.plus.osmedit.LocalOpenstreetmapActivity: void onResume()>
	3: <net.osmand.plus.osmedit.OsmBugsDbHelper: java.util.List getOsmbugsPoints()>
	4: <net.osmand.plus.osmedit.OsmBugsDbHelper: java.util.List checkOsmbugsPoints()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.resources.ResourceManager: void <init>(net.osmand.plus.OsmandApplication)>
	3: <net.osmand.plus.resources.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.activities.MapActivityLayers$10$1: void run()>
	5: <net.osmand.plus.activities.MapActivityLayers$5: boolean processResult(java.lang.Object)>
	6: <net.osmand.plus.activities.MapActivityLayers$5: boolean processResult(net.osmand.plus.GPXUtilities$GPXFile)>
	7: <net.osmand.plus.activities.SavingTrackHelper: java.util.Map collectRecordedData()>
	8: <net.osmand.plus.activities.SavingTrackHelper: void collectDBTracks(android.database.sqlite.SQLiteDatabase,java.util.Map)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.resources.ResourceManager: void <init>(net.osmand.plus.OsmandApplication)>
	3: <net.osmand.plus.resources.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.activities.MapActivityLayers$10$1: void run()>
	5: <net.osmand.plus.activities.MapActivityLayers$5: boolean processResult(java.lang.Object)>
	6: <net.osmand.plus.activities.MapActivityLayers$5: boolean processResult(net.osmand.plus.GPXUtilities$GPXFile)>
	7: <net.osmand.plus.activities.SavingTrackHelper: java.util.Map collectRecordedData()>
	8: <net.osmand.plus.activities.SavingTrackHelper: void collectDBPoints(android.database.sqlite.SQLiteDatabase,java.util.Map)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.resources.ResourceManager: void <init>(net.osmand.plus.OsmandApplication)>
	3: <net.osmand.plus.resources.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.OsmandApplication$6: void run()>
	5: <net.osmand.plus.OsmandApplication: void access$300(net.osmand.plus.OsmandApplication)>
	6: <net.osmand.plus.OsmandApplication: void startApplicationBackground()>
	7: <net.osmand.plus.activities.SavingTrackHelper: boolean hasDataToSave()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivity: void onResume()>
	3: <net.osmand.plus.views.OsmandMapTileView: void refreshMap(boolean)>
	4: <net.osmand.plus.views.OsmandMapTileView: void refreshBufferImage(net.osmand.plus.views.OsmandMapLayer$DrawSettings)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.io.File,android.database.sqlite.SQLiteDatabase$CursorFactory)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.search.SearchStreetByNameActivity dummyMainMethod_net_osmand_plus_activities_search_SearchStreetByNameActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.search.SearchByNameAbstractActivity: void onCreate(android.os.Bundle)>
	3: <net.osmand.plus.srtmplugin.HillshadeLayer$1: java.lang.Object doInBackground(java.lang.Object[])>
	4: <net.osmand.plus.srtmplugin.HillshadeLayer$1: java.lang.Void doInBackground(java.lang.Void[])>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivity: void onResume()>
	3: <net.osmand.plus.views.OsmandMapTileView: void refreshMap(boolean)>
	4: <net.osmand.plus.views.OsmandMapTileView: void sendRefreshMapMsg(net.osmand.plus.views.OsmandMapLayer$DrawSettings,int)>

File does not exist: ./DroidLeaks/apps/CallMeter-rev-aed879c8a6.apk
File does not exist: ./DroidLeaks/apps/CallMeter-rev-aed879c8a6.apk
File does not exist: ./DroidLeaks/apps/CallMeter-rev-a6688d9fbc.apk
File does not exist: ./DroidLeaks/apps/CallMeter-rev-4c5f567e81.apk
File does not exist: ./DroidLeaks/apps/CallMeter-rev-9500b4240c.apk
File does not exist: ./DroidLeaks/apps/CallMeter-rev-14f44523a5.apk
File does not exist: ./DroidLeaks/apps/ConnectBot-rev-34a2c4a660.apk
Resource: android.database.Cursor
source method: getConversation() @line 238
source file: Conversation.java
Our analysis output:
Soot started on Sun May 03 01:56:14 EDT 2020
Soot finished on Sun May 03 01:56:20 EDT 2020
Soot has run for 0 min. 5 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: de.ub0r.android.smsdroid.ConversationProvider dummyMainMethod_de_ub0r_android_smsdroid_ConversationProvider(android.content.Intent)>
	2: <de.ub0r.android.smsdroid.ConversationProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <de.ub0r.android.smsdroid.ConversationProvider: void updateSource(android.database.sqlite.SQLiteDatabase)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: de.ub0r.android.smsdroid.ConversationProvider dummyMainMethod_de_ub0r_android_smsdroid_ConversationProvider(android.content.Intent)>
	2: <de.ub0r.android.smsdroid.ConversationProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <de.ub0r.android.smsdroid.ConversationProvider: void updateSource(android.database.sqlite.SQLiteDatabase)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: de.ub0r.android.smsdroid.ConversationList dummyMainMethod_de_ub0r_android_smsdroid_ConversationList(android.content.Intent)>
	2: <de.ub0r.android.smsdroid.ConversationList: void onCreate(android.os.Bundle)>
	3: <de.ub0r.android.smsdroid.ConversationAdapter: void <init>(de.ub0r.android.smsdroid.ConversationList)>
	4: <de.ub0r.android.smsdroid.SpamDB: java.lang.String[] getAllEntries()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: de.ub0r.android.smsdroid.SmsReceiver dummyMainMethod_de_ub0r_android_smsdroid_SmsReceiver(android.content.Intent)>
	2: <de.ub0r.android.smsdroid.SmsReceiver: void onReceive(android.content.Context,android.content.Intent)>
	3: <de.ub0r.android.smsdroid.SpamDB: boolean isInDB(java.lang.String)>

File does not exist: ./DroidLeaks/apps/SMSDroid-rev-01218844ba.apk
File does not exist: ./DroidLeaks/apps/Open-GPSTracker-rev-ba72b95903.apk
File does not exist: ./DroidLeaks/apps/Bitcoin-wallet-rev-e05dfb7fae.apk
File does not exist: ./DroidLeaks/apps/Bitcoin-wallet-rev-e05dfb7fae.apk
File does not exist: ./DroidLeaks/apps/Cgeo-rev-42e4da93bc.apk
File does not exist: ./DroidLeaks/apps/Google Authenticator-rev-f7dee7574d.apk
File does not exist: ./DroidLeaks/apps/Google Authenticator-rev-f7dee7574d.apk
File does not exist: ./DroidLeaks/apps/Google Authenticator-rev-f7dee7574d.apk
File does not exist: ./DroidLeaks/apps/Google Authenticator-rev-f7dee7574d.apk
File does not exist: ./DroidLeaks/apps/Google Authenticator-rev-f7dee7574d.apk
File does not exist: ./DroidLeaks/apps/Owncloud-rev-1b628540c92.apk
File does not exist: ./DroidLeaks/apps/Owncloud-rev-1b628540c92.apk
File does not exist: ./DroidLeaks/apps/Owncloud-rev-1b628540c92.apk
File does not exist: ./DroidLeaks/apps/Owncloud-rev-35ace0b973.apk
File does not exist: ./DroidLeaks/apps/Owncloud-rev-35ace0b973.apk
File does not exist: ./DroidLeaks/apps/Owncloud-rev-f12956fe2a.apk
Resource: android.database.Cursor
source method: accountFromDb() @line 191
source file: BankFactory.java
Our analysis output:
Soot started on Sun May 03 01:56:25 EDT 2020
Soot finished on Sun May 03 01:56:30 EDT 2020
Soot has run for 0 min. 5 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Account accountFromDb(android.content.Context,java.lang.String,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchTransactions(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Bank bankFromDb(long,android.content.Context,boolean)>
	4: <com.liato.bankdroid.BankFactory: java.util.ArrayList accountsFromDb(android.content.Context,long)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchAccounts(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Account accountFromDb(android.content.Context,java.lang.String,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor getAccount(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.MainActivity dummyMainMethod_com_liato_bankdroid_MainActivity(android.content.Intent)>
	2: <com.liato.bankdroid.MainActivity: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.liato.bankdroid.MainActivity: void refreshView()>
	4: <com.liato.bankdroid.BankFactory: java.util.ArrayList banksFromDb(android.content.Context,boolean)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchBanks()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Bank bankFromDb(long,android.content.Context,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor getBank(long)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor getBank(java.lang.String)>

File does not exist: ./DroidLeaks/apps/Quran for Android-rev-a01cd99835.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-a01cd99835.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-a01cd99835.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-a01cd99835.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-a01cd99835.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-a01cd99835.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-a01cd99835.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-a01cd99835.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-a01cd99835.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-a01cd99835.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-a01cd99835.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-f5c4be3db0.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-185f5a517d.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-058a1256c4.apk
Resource: android.database.Cursor
source method: deleteAllTracks()
source file: TrackManager.java
Our analysis output:
Soot started on Sun May 03 01:56:36 EDT 2020
Soot finished on Sun May 03 01:56:42 EDT 2020
Soot has run for 0 min. 5 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: android.database.Cursor
source method: manageNewStoragePath()
source file: DatabaseHelper.java
Our analysis output:
Soot started on Sun May 03 01:56:47 EDT 2020
Soot finished on Sun May 03 01:56:53 EDT 2020
Soot has run for 0 min. 5 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: android.database.Cursor
source method: readExtraInformation() @line 63
source file: Track.java
Our analysis output:
Soot started on Sun May 03 01:56:59 EDT 2020
Soot finished on Sun May 03 01:57:05 EDT 2020
Soot has run for 0 min. 5 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: android.database.Cursor
source method: readExtraInformation() @line 68
source file: Track.java
Our analysis output:
Soot started on Sun May 03 01:57:10 EDT 2020
Soot finished on Sun May 03 01:57:16 EDT 2020
Soot has run for 0 min. 5 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

File does not exist: ./DroidLeaks/apps/IRCCloud-rev-5f8ca597a5.apk
File does not exist: ./DroidLeaks/apps/IRCCloud-rev-5f8ca597a5.apk
File does not exist: ./DroidLeaks/apps/IRCCloud-rev-5f8ca597a5.apk
File does not exist: ./DroidLeaks/apps/IRCCloud-rev-5f8ca597a5.apk
File does not exist: ./DroidLeaks/apps/IRCCloud-rev-5f8ca597a5.apk
Resource: android.database.Cursor
source method: doInBackground() @line 4438
source file: MainActivity.java
Our analysis output:
Soot started on Sun May 03 01:57:21 EDT 2020
Soot finished on Sun May 03 01:57:51 EDT 2020
Soot has run for 0 min. 29 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

File does not exist: ./DroidLeaks/apps/VLC-rev-10b0263c57.apk
File does not exist: ./DroidLeaks/apps/VLC-rev-10b0263c57.apk
File does not exist: ./DroidLeaks/apps/VLC-rev-7573d27b67.apk
File does not exist: ./DroidLeaks/apps/VLC-rev-960052e069.apk
File does not exist: ./DroidLeaks/apps/VLC-rev-52c095c0b8.apk
File does not exist: ./DroidLeaks/apps/VLC-rev-dfdc88d64f.apk
File does not exist: ./DroidLeaks/apps/VLC-rev-1cc3fc69d8.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-480fcb3c4d.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-657bf0c2cf.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-003f846a5b.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-42de8a232c.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-380064faa9.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-380064faa9.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-380064faa9.apk
Resource: android.database.Cursor
source method: swapCursor()
source file: MediaGridAdapter.java
Our analysis output:
Soot started on Sun May 03 01:58:23 EDT 2020
Soot finished on Sun May 03 01:59:03 EDT 2020
Soot has run for 0 min. 39 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean expandActionView()>
	4: <com.actionbarsherlock.internal.view.menu.MenuBuilder: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	5: <com.actionbarsherlock.internal.widget.ActionBarView$ExpandedActionViewMenuPresenter: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuBuilder,com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	6: <com.actionbarsherlock.widget.SearchView: void onActionViewExpanded()>
	7: <com.actionbarsherlock.widget.SearchView: void setIconified(boolean)>
	8: <com.actionbarsherlock.widget.SearchView: void onSearchClicked()>
	9: <com.actionbarsherlock.widget.SearchView$7: void onClick(android.view.View)>
	10: <com.actionbarsherlock.widget.SearchView: void access$1000(com.actionbarsherlock.widget.SearchView)>
	11: <com.actionbarsherlock.widget.SearchView: void onSubmitQuery()>
	12: <org.wordpress.android.ui.themes.ThemeSearchFragment: boolean onQueryTextSubmit(java.lang.String)>
	13: <org.wordpress.android.ui.themes.ThemeSearchFragment: void search(java.lang.String)>
	14: <org.wordpress.android.WordPressDB: android.database.Cursor getThemes(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesPopularity(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.media.MediaEditFragment: void loadMedia(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFile(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migrateWPComAccount()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaImagesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.AddQuickPressShortcutActivity dummyMainMethod_org_wordpress_android_ui_AddQuickPressShortcutActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.AddQuickPressShortcutActivity: void onActivityResult(int,int,android.content.Intent)>
	3: <org.wordpress.android.WordPressDB: java.util.List getAccounts()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesNewest(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.view.menu.MenuPopupHelper: void onGlobalLayout()>
	3: <com.actionbarsherlock.internal.widget.IcsSpinner$DropdownPopup: void show()>
	4: <com.actionbarsherlock.internal.widget.IcsSpinner: int measureContentWidth(android.widget.SpinnerAdapter,android.graphics.drawable.Drawable)>
	5: <org.wordpress.android.ui.WPActionBarActivity$MenuAdapter: android.view.View getView(int,android.view.View,android.view.ViewGroup)>
	6: <org.wordpress.android.ui.WPActionBarActivity$CommentsMenuItem: void configureView(android.view.View)>
	7: <org.wordpress.android.models.Blog: int getUnmoderatedCommentCount()>
	8: <org.wordpress.android.WordPressDB: int getUnmoderatedCommentCount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: int getCategoryParentId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUnattachedForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$2: void run()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: void onMediaItemListDownloaded()>
	5: <org.wordpress.android.ui.media.MediaItemFragment: void loadDefaultMedia()>
	6: <org.wordpress.android.ui.media.MediaItemFragment: void loadMedia(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getFirstMediaFileForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.AddCategoryActivity dummyMainMethod_org_wordpress_android_ui_posts_AddCategoryActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.AddCategoryActivity$1: void onClick(android.view.View)>
	3: <org.wordpress.android.WordPressDB: int getCategoryId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: void onPause()>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean collapseActionView()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onMenuItemActionCollapse(com.actionbarsherlock.view.MenuItem)>
	5: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onQueryTextChange(java.lang.String)>
	6: <org.wordpress.android.ui.media.MediaGridFragment: void search(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.WPActionBarActivity$1: void onItemClick(android.widget.AdapterView,android.view.View,int,long)>
	3: <org.wordpress.android.ui.MenuDrawerItem: void selectItem()>
	4: <org.wordpress.android.ui.WPActionBarActivity$ReaderMenuItem: void onSelectItem()>
	5: <org.wordpress.android.WordPressDB: int getWPCOMBlogID()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.posts.PostsActivity: void checkForLocalChanges(boolean)>
	4: <org.wordpress.android.WordPressDB: boolean findLocalChanges()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.comments.CommentsActivity dummyMainMethod_org_wordpress_android_ui_comments_CommentsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.comments.CommentsActivity: void onPostResume()>
	3: <org.wordpress.android.ui.comments.CommentsListFragment: boolean loadComments(boolean,boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadComments(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaDeleteService$1: void run()>
	4: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor access$000(org.wordpress.android.util.MediaDeleteService)>
	5: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor getQueueItem()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaDeleteQueueItem(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.models.Post: void <init>(int,long,boolean)>
	3: <org.wordpress.android.WordPressDB: java.util.List loadPost(int,boolean,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.PostUploadService dummyMainMethod_org_wordpress_android_util_PostUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.PostUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.PostUploadService: void uploadNextPost()>
	4: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Boolean doInBackground(org.wordpress.android.models.Post[])>
	6: <org.wordpress.android.WordPressDB: org.wordpress.android.models.MediaFile getMediaFile(java.lang.String,org.wordpress.android.models.Post)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.lang.String getInterval()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: java.util.List loadCategories(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.util.Map getNotificationOptions()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.accounts.AccountSetupActivity$XMLRPCMethod$1: void run()>
	4: <org.wordpress.android.ui.accounts.AccountSetupActivity$1: void callFinished(java.lang.Object[])>
	5: <org.wordpress.android.WordPressDB: long checkMatch(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.prefs.LicensesActivity dummyMainMethod_org_wordpress_android_ui_prefs_LicensesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaGridFragment$4: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment: void setDateFilter()>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.themes.ThemeBrowserActivity: void onResume()>
	3: <org.wordpress.android.WordPressDB: int getThemeCount(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesAtoZ(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.models.Blog: void <init>(int)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadSettings(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesTrending(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaUploadService$1: void run()>
	4: <org.wordpress.android.util.MediaUploadService: android.database.Cursor access$000(org.wordpress.android.util.MediaUploadService)>
	5: <org.wordpress.android.util.MediaUploadService: android.database.Cursor getQueue()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUploadQueue(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.SQLTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePasswords()>

Resource: android.database.Cursor
source method: setFilter()
source file: MediaGridFragment.java
Our analysis output:
Soot started on Sun May 03 01:59:46 EDT 2020
Soot finished on Sun May 03 02:00:27 EDT 2020
Soot has run for 0 min. 40 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean expandActionView()>
	4: <com.actionbarsherlock.internal.view.menu.MenuBuilder: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	5: <com.actionbarsherlock.internal.widget.ActionBarView$ExpandedActionViewMenuPresenter: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuBuilder,com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	6: <com.actionbarsherlock.widget.SearchView: void onActionViewExpanded()>
	7: <com.actionbarsherlock.widget.SearchView: void setIconified(boolean)>
	8: <com.actionbarsherlock.widget.SearchView: void onSearchClicked()>
	9: <com.actionbarsherlock.widget.SearchView$7: void onClick(android.view.View)>
	10: <com.actionbarsherlock.widget.SearchView: void access$1000(com.actionbarsherlock.widget.SearchView)>
	11: <com.actionbarsherlock.widget.SearchView: void onSubmitQuery()>
	12: <org.wordpress.android.ui.themes.ThemeSearchFragment: boolean onQueryTextSubmit(java.lang.String)>
	13: <org.wordpress.android.ui.themes.ThemeSearchFragment: void search(java.lang.String)>
	14: <org.wordpress.android.WordPressDB: android.database.Cursor getThemes(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesPopularity(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.media.MediaEditFragment: void loadMedia(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFile(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migrateWPComAccount()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaImagesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.AddQuickPressShortcutActivity dummyMainMethod_org_wordpress_android_ui_AddQuickPressShortcutActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.AddQuickPressShortcutActivity: void onActivityResult(int,int,android.content.Intent)>
	3: <org.wordpress.android.WordPressDB: java.util.List getAccounts()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesNewest(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.view.menu.MenuPopupHelper: void onGlobalLayout()>
	3: <com.actionbarsherlock.internal.widget.IcsSpinner$DropdownPopup: void show()>
	4: <com.actionbarsherlock.internal.widget.IcsSpinner: int measureContentWidth(android.widget.SpinnerAdapter,android.graphics.drawable.Drawable)>
	5: <org.wordpress.android.ui.WPActionBarActivity$MenuAdapter: android.view.View getView(int,android.view.View,android.view.ViewGroup)>
	6: <org.wordpress.android.ui.WPActionBarActivity$CommentsMenuItem: void configureView(android.view.View)>
	7: <org.wordpress.android.models.Blog: int getUnmoderatedCommentCount()>
	8: <org.wordpress.android.WordPressDB: int getUnmoderatedCommentCount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: int getCategoryParentId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUnattachedForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$2: void run()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: void onMediaItemListDownloaded()>
	5: <org.wordpress.android.ui.media.MediaItemFragment: void loadDefaultMedia()>
	6: <org.wordpress.android.ui.media.MediaItemFragment: void loadMedia(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getFirstMediaFileForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.AddCategoryActivity dummyMainMethod_org_wordpress_android_ui_posts_AddCategoryActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.AddCategoryActivity$1: void onClick(android.view.View)>
	3: <org.wordpress.android.WordPressDB: int getCategoryId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: void onPause()>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean collapseActionView()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onMenuItemActionCollapse(com.actionbarsherlock.view.MenuItem)>
	5: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onQueryTextChange(java.lang.String)>
	6: <org.wordpress.android.ui.media.MediaGridFragment: void search(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.WPActionBarActivity$1: void onItemClick(android.widget.AdapterView,android.view.View,int,long)>
	3: <org.wordpress.android.ui.MenuDrawerItem: void selectItem()>
	4: <org.wordpress.android.ui.WPActionBarActivity$ReaderMenuItem: void onSelectItem()>
	5: <org.wordpress.android.WordPressDB: int getWPCOMBlogID()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.posts.PostsActivity: void checkForLocalChanges(boolean)>
	4: <org.wordpress.android.WordPressDB: boolean findLocalChanges()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.comments.CommentsActivity dummyMainMethod_org_wordpress_android_ui_comments_CommentsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.comments.CommentsActivity: void onPostResume()>
	3: <org.wordpress.android.ui.comments.CommentsListFragment: boolean loadComments(boolean,boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadComments(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaDeleteService$1: void run()>
	4: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor access$000(org.wordpress.android.util.MediaDeleteService)>
	5: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor getQueueItem()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaDeleteQueueItem(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.models.Post: void <init>(int,long,boolean)>
	3: <org.wordpress.android.WordPressDB: java.util.List loadPost(int,boolean,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.PostUploadService dummyMainMethod_org_wordpress_android_util_PostUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.PostUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.PostUploadService: void uploadNextPost()>
	4: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Boolean doInBackground(org.wordpress.android.models.Post[])>
	6: <org.wordpress.android.WordPressDB: org.wordpress.android.models.MediaFile getMediaFile(java.lang.String,org.wordpress.android.models.Post)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.lang.String getInterval()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: java.util.List loadCategories(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.util.Map getNotificationOptions()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.accounts.AccountSetupActivity$XMLRPCMethod$1: void run()>
	4: <org.wordpress.android.ui.accounts.AccountSetupActivity$1: void callFinished(java.lang.Object[])>
	5: <org.wordpress.android.WordPressDB: long checkMatch(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.prefs.LicensesActivity dummyMainMethod_org_wordpress_android_ui_prefs_LicensesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaGridFragment$4: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment: void setDateFilter()>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.themes.ThemeBrowserActivity: void onResume()>
	3: <org.wordpress.android.WordPressDB: int getThemeCount(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesAtoZ(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.models.Blog: void <init>(int)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadSettings(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesTrending(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaUploadService$1: void run()>
	4: <org.wordpress.android.util.MediaUploadService: android.database.Cursor access$000(org.wordpress.android.util.MediaUploadService)>
	5: <org.wordpress.android.util.MediaUploadService: android.database.Cursor getQueue()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUploadQueue(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.SQLTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePasswords()>

Resource: android.database.Cursor
source method: setDateFilter()
source file: MediaGridFragment.java
Our analysis output:
Soot started on Sun May 03 02:01:10 EDT 2020
Soot finished on Sun May 03 02:01:52 EDT 2020
Soot has run for 0 min. 42 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean expandActionView()>
	4: <com.actionbarsherlock.internal.view.menu.MenuBuilder: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	5: <com.actionbarsherlock.internal.widget.ActionBarView$ExpandedActionViewMenuPresenter: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuBuilder,com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	6: <com.actionbarsherlock.widget.SearchView: void onActionViewExpanded()>
	7: <com.actionbarsherlock.widget.SearchView: void setIconified(boolean)>
	8: <com.actionbarsherlock.widget.SearchView: void onSearchClicked()>
	9: <com.actionbarsherlock.widget.SearchView$7: void onClick(android.view.View)>
	10: <com.actionbarsherlock.widget.SearchView: void access$1000(com.actionbarsherlock.widget.SearchView)>
	11: <com.actionbarsherlock.widget.SearchView: void onSubmitQuery()>
	12: <org.wordpress.android.ui.themes.ThemeSearchFragment: boolean onQueryTextSubmit(java.lang.String)>
	13: <org.wordpress.android.ui.themes.ThemeSearchFragment: void search(java.lang.String)>
	14: <org.wordpress.android.WordPressDB: android.database.Cursor getThemes(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesPopularity(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.media.MediaEditFragment: void loadMedia(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFile(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migrateWPComAccount()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaImagesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.AddQuickPressShortcutActivity dummyMainMethod_org_wordpress_android_ui_AddQuickPressShortcutActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.AddQuickPressShortcutActivity: void onActivityResult(int,int,android.content.Intent)>
	3: <org.wordpress.android.WordPressDB: java.util.List getAccounts()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesNewest(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.view.menu.MenuPopupHelper: void onGlobalLayout()>
	3: <com.actionbarsherlock.internal.widget.IcsSpinner$DropdownPopup: void show()>
	4: <com.actionbarsherlock.internal.widget.IcsSpinner: int measureContentWidth(android.widget.SpinnerAdapter,android.graphics.drawable.Drawable)>
	5: <org.wordpress.android.ui.WPActionBarActivity$MenuAdapter: android.view.View getView(int,android.view.View,android.view.ViewGroup)>
	6: <org.wordpress.android.ui.WPActionBarActivity$CommentsMenuItem: void configureView(android.view.View)>
	7: <org.wordpress.android.models.Blog: int getUnmoderatedCommentCount()>
	8: <org.wordpress.android.WordPressDB: int getUnmoderatedCommentCount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: int getCategoryParentId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUnattachedForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$2: void run()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: void onMediaItemListDownloaded()>
	5: <org.wordpress.android.ui.media.MediaItemFragment: void loadDefaultMedia()>
	6: <org.wordpress.android.ui.media.MediaItemFragment: void loadMedia(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getFirstMediaFileForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.AddCategoryActivity dummyMainMethod_org_wordpress_android_ui_posts_AddCategoryActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.AddCategoryActivity$1: void onClick(android.view.View)>
	3: <org.wordpress.android.WordPressDB: int getCategoryId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: void onPause()>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean collapseActionView()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onMenuItemActionCollapse(com.actionbarsherlock.view.MenuItem)>
	5: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onQueryTextChange(java.lang.String)>
	6: <org.wordpress.android.ui.media.MediaGridFragment: void search(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.WPActionBarActivity$1: void onItemClick(android.widget.AdapterView,android.view.View,int,long)>
	3: <org.wordpress.android.ui.MenuDrawerItem: void selectItem()>
	4: <org.wordpress.android.ui.WPActionBarActivity$ReaderMenuItem: void onSelectItem()>
	5: <org.wordpress.android.WordPressDB: int getWPCOMBlogID()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.posts.PostsActivity: void checkForLocalChanges(boolean)>
	4: <org.wordpress.android.WordPressDB: boolean findLocalChanges()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.comments.CommentsActivity dummyMainMethod_org_wordpress_android_ui_comments_CommentsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.comments.CommentsActivity: void onPostResume()>
	3: <org.wordpress.android.ui.comments.CommentsListFragment: boolean loadComments(boolean,boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadComments(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaDeleteService$1: void run()>
	4: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor access$000(org.wordpress.android.util.MediaDeleteService)>
	5: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor getQueueItem()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaDeleteQueueItem(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.models.Post: void <init>(int,long,boolean)>
	3: <org.wordpress.android.WordPressDB: java.util.List loadPost(int,boolean,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.PostUploadService dummyMainMethod_org_wordpress_android_util_PostUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.PostUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.PostUploadService: void uploadNextPost()>
	4: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Boolean doInBackground(org.wordpress.android.models.Post[])>
	6: <org.wordpress.android.WordPressDB: org.wordpress.android.models.MediaFile getMediaFile(java.lang.String,org.wordpress.android.models.Post)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.lang.String getInterval()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: java.util.List loadCategories(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.util.Map getNotificationOptions()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.accounts.AccountSetupActivity$XMLRPCMethod$1: void run()>
	4: <org.wordpress.android.ui.accounts.AccountSetupActivity$1: void callFinished(java.lang.Object[])>
	5: <org.wordpress.android.WordPressDB: long checkMatch(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.prefs.LicensesActivity dummyMainMethod_org_wordpress_android_ui_prefs_LicensesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaGridFragment$4: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment: void setDateFilter()>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.themes.ThemeBrowserActivity: void onResume()>
	3: <org.wordpress.android.WordPressDB: int getThemeCount(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesAtoZ(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.models.Blog: void <init>(int)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadSettings(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesTrending(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaUploadService$1: void run()>
	4: <org.wordpress.android.util.MediaUploadService: android.database.Cursor access$000(org.wordpress.android.util.MediaUploadService)>
	5: <org.wordpress.android.util.MediaUploadService: android.database.Cursor getQueue()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUploadQueue(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.SQLTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePasswords()>

Resource: android.database.Cursor
source method: reset()
source file: MediaGridFragment.java
Our analysis output:
Soot started on Sun May 03 02:02:37 EDT 2020
Soot finished on Sun May 03 02:03:17 EDT 2020
Soot has run for 0 min. 39 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean expandActionView()>
	4: <com.actionbarsherlock.internal.view.menu.MenuBuilder: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	5: <com.actionbarsherlock.internal.widget.ActionBarView$ExpandedActionViewMenuPresenter: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuBuilder,com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	6: <com.actionbarsherlock.widget.SearchView: void onActionViewExpanded()>
	7: <com.actionbarsherlock.widget.SearchView: void setIconified(boolean)>
	8: <com.actionbarsherlock.widget.SearchView: void onSearchClicked()>
	9: <com.actionbarsherlock.widget.SearchView$7: void onClick(android.view.View)>
	10: <com.actionbarsherlock.widget.SearchView: void access$1000(com.actionbarsherlock.widget.SearchView)>
	11: <com.actionbarsherlock.widget.SearchView: void onSubmitQuery()>
	12: <org.wordpress.android.ui.themes.ThemeSearchFragment: boolean onQueryTextSubmit(java.lang.String)>
	13: <org.wordpress.android.ui.themes.ThemeSearchFragment: void search(java.lang.String)>
	14: <org.wordpress.android.WordPressDB: android.database.Cursor getThemes(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesPopularity(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.media.MediaEditFragment: void loadMedia(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFile(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migrateWPComAccount()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaImagesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.AddQuickPressShortcutActivity dummyMainMethod_org_wordpress_android_ui_AddQuickPressShortcutActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.AddQuickPressShortcutActivity: void onActivityResult(int,int,android.content.Intent)>
	3: <org.wordpress.android.WordPressDB: java.util.List getAccounts()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesNewest(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.view.menu.MenuPopupHelper: void onGlobalLayout()>
	3: <com.actionbarsherlock.internal.widget.IcsSpinner$DropdownPopup: void show()>
	4: <com.actionbarsherlock.internal.widget.IcsSpinner: int measureContentWidth(android.widget.SpinnerAdapter,android.graphics.drawable.Drawable)>
	5: <org.wordpress.android.ui.WPActionBarActivity$MenuAdapter: android.view.View getView(int,android.view.View,android.view.ViewGroup)>
	6: <org.wordpress.android.ui.WPActionBarActivity$CommentsMenuItem: void configureView(android.view.View)>
	7: <org.wordpress.android.models.Blog: int getUnmoderatedCommentCount()>
	8: <org.wordpress.android.WordPressDB: int getUnmoderatedCommentCount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: int getCategoryParentId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUnattachedForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$2: void run()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: void onMediaItemListDownloaded()>
	5: <org.wordpress.android.ui.media.MediaItemFragment: void loadDefaultMedia()>
	6: <org.wordpress.android.ui.media.MediaItemFragment: void loadMedia(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getFirstMediaFileForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.AddCategoryActivity dummyMainMethod_org_wordpress_android_ui_posts_AddCategoryActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.AddCategoryActivity$1: void onClick(android.view.View)>
	3: <org.wordpress.android.WordPressDB: int getCategoryId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: void onPause()>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean collapseActionView()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onMenuItemActionCollapse(com.actionbarsherlock.view.MenuItem)>
	5: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onQueryTextChange(java.lang.String)>
	6: <org.wordpress.android.ui.media.MediaGridFragment: void search(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.WPActionBarActivity$1: void onItemClick(android.widget.AdapterView,android.view.View,int,long)>
	3: <org.wordpress.android.ui.MenuDrawerItem: void selectItem()>
	4: <org.wordpress.android.ui.WPActionBarActivity$ReaderMenuItem: void onSelectItem()>
	5: <org.wordpress.android.WordPressDB: int getWPCOMBlogID()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.posts.PostsActivity: void checkForLocalChanges(boolean)>
	4: <org.wordpress.android.WordPressDB: boolean findLocalChanges()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.comments.CommentsActivity dummyMainMethod_org_wordpress_android_ui_comments_CommentsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.comments.CommentsActivity: void onPostResume()>
	3: <org.wordpress.android.ui.comments.CommentsListFragment: boolean loadComments(boolean,boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadComments(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaDeleteService$1: void run()>
	4: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor access$000(org.wordpress.android.util.MediaDeleteService)>
	5: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor getQueueItem()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaDeleteQueueItem(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.models.Post: void <init>(int,long,boolean)>
	3: <org.wordpress.android.WordPressDB: java.util.List loadPost(int,boolean,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.PostUploadService dummyMainMethod_org_wordpress_android_util_PostUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.PostUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.PostUploadService: void uploadNextPost()>
	4: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Boolean doInBackground(org.wordpress.android.models.Post[])>
	6: <org.wordpress.android.WordPressDB: org.wordpress.android.models.MediaFile getMediaFile(java.lang.String,org.wordpress.android.models.Post)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.lang.String getInterval()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: java.util.List loadCategories(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.util.Map getNotificationOptions()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.accounts.AccountSetupActivity$XMLRPCMethod$1: void run()>
	4: <org.wordpress.android.ui.accounts.AccountSetupActivity$1: void callFinished(java.lang.Object[])>
	5: <org.wordpress.android.WordPressDB: long checkMatch(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.prefs.LicensesActivity dummyMainMethod_org_wordpress_android_ui_prefs_LicensesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaGridFragment$4: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment: void setDateFilter()>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.themes.ThemeBrowserActivity: void onResume()>
	3: <org.wordpress.android.WordPressDB: int getThemeCount(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesAtoZ(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.models.Blog: void <init>(int)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadSettings(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesTrending(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaUploadService$1: void run()>
	4: <org.wordpress.android.util.MediaUploadService: android.database.Cursor access$000(org.wordpress.android.util.MediaUploadService)>
	5: <org.wordpress.android.util.MediaUploadService: android.database.Cursor getQueue()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUploadQueue(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.SQLTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePasswords()>

Resource: android.database.Cursor
source method: onLoadFinished()
source file: StatsCursorFragment.java
Our analysis output:
Soot started on Sun May 03 02:04:00 EDT 2020
Soot finished on Sun May 03 02:04:40 EDT 2020
Soot has run for 0 min. 39 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean expandActionView()>
	4: <com.actionbarsherlock.internal.view.menu.MenuBuilder: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	5: <com.actionbarsherlock.internal.widget.ActionBarView$ExpandedActionViewMenuPresenter: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuBuilder,com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	6: <com.actionbarsherlock.widget.SearchView: void onActionViewExpanded()>
	7: <com.actionbarsherlock.widget.SearchView: void setIconified(boolean)>
	8: <com.actionbarsherlock.widget.SearchView: void onSearchClicked()>
	9: <com.actionbarsherlock.widget.SearchView$7: void onClick(android.view.View)>
	10: <com.actionbarsherlock.widget.SearchView: void access$1000(com.actionbarsherlock.widget.SearchView)>
	11: <com.actionbarsherlock.widget.SearchView: void onSubmitQuery()>
	12: <org.wordpress.android.ui.themes.ThemeSearchFragment: boolean onQueryTextSubmit(java.lang.String)>
	13: <org.wordpress.android.ui.themes.ThemeSearchFragment: void search(java.lang.String)>
	14: <org.wordpress.android.WordPressDB: android.database.Cursor getThemes(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesPopularity(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.media.MediaEditFragment: void loadMedia(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFile(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migrateWPComAccount()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaImagesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.AddQuickPressShortcutActivity dummyMainMethod_org_wordpress_android_ui_AddQuickPressShortcutActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.AddQuickPressShortcutActivity: void onActivityResult(int,int,android.content.Intent)>
	3: <org.wordpress.android.WordPressDB: java.util.List getAccounts()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesNewest(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.view.menu.MenuPopupHelper: void onGlobalLayout()>
	3: <com.actionbarsherlock.internal.widget.IcsSpinner$DropdownPopup: void show()>
	4: <com.actionbarsherlock.internal.widget.IcsSpinner: int measureContentWidth(android.widget.SpinnerAdapter,android.graphics.drawable.Drawable)>
	5: <org.wordpress.android.ui.WPActionBarActivity$MenuAdapter: android.view.View getView(int,android.view.View,android.view.ViewGroup)>
	6: <org.wordpress.android.ui.WPActionBarActivity$CommentsMenuItem: void configureView(android.view.View)>
	7: <org.wordpress.android.models.Blog: int getUnmoderatedCommentCount()>
	8: <org.wordpress.android.WordPressDB: int getUnmoderatedCommentCount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: int getCategoryParentId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUnattachedForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$2: void run()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: void onMediaItemListDownloaded()>
	5: <org.wordpress.android.ui.media.MediaItemFragment: void loadDefaultMedia()>
	6: <org.wordpress.android.ui.media.MediaItemFragment: void loadMedia(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getFirstMediaFileForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.AddCategoryActivity dummyMainMethod_org_wordpress_android_ui_posts_AddCategoryActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.AddCategoryActivity$1: void onClick(android.view.View)>
	3: <org.wordpress.android.WordPressDB: int getCategoryId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: void onPause()>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean collapseActionView()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onMenuItemActionCollapse(com.actionbarsherlock.view.MenuItem)>
	5: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onQueryTextChange(java.lang.String)>
	6: <org.wordpress.android.ui.media.MediaGridFragment: void search(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.WPActionBarActivity$1: void onItemClick(android.widget.AdapterView,android.view.View,int,long)>
	3: <org.wordpress.android.ui.MenuDrawerItem: void selectItem()>
	4: <org.wordpress.android.ui.WPActionBarActivity$ReaderMenuItem: void onSelectItem()>
	5: <org.wordpress.android.WordPressDB: int getWPCOMBlogID()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.posts.PostsActivity: void checkForLocalChanges(boolean)>
	4: <org.wordpress.android.WordPressDB: boolean findLocalChanges()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.comments.CommentsActivity dummyMainMethod_org_wordpress_android_ui_comments_CommentsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.comments.CommentsActivity: void onPostResume()>
	3: <org.wordpress.android.ui.comments.CommentsListFragment: boolean loadComments(boolean,boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadComments(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaDeleteService$1: void run()>
	4: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor access$000(org.wordpress.android.util.MediaDeleteService)>
	5: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor getQueueItem()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaDeleteQueueItem(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.models.Post: void <init>(int,long,boolean)>
	3: <org.wordpress.android.WordPressDB: java.util.List loadPost(int,boolean,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.PostUploadService dummyMainMethod_org_wordpress_android_util_PostUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.PostUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.PostUploadService: void uploadNextPost()>
	4: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Boolean doInBackground(org.wordpress.android.models.Post[])>
	6: <org.wordpress.android.WordPressDB: org.wordpress.android.models.MediaFile getMediaFile(java.lang.String,org.wordpress.android.models.Post)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.lang.String getInterval()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: java.util.List loadCategories(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.util.Map getNotificationOptions()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.accounts.AccountSetupActivity$XMLRPCMethod$1: void run()>
	4: <org.wordpress.android.ui.accounts.AccountSetupActivity$1: void callFinished(java.lang.Object[])>
	5: <org.wordpress.android.WordPressDB: long checkMatch(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.prefs.LicensesActivity dummyMainMethod_org_wordpress_android_ui_prefs_LicensesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaGridFragment$4: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment: void setDateFilter()>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.themes.ThemeBrowserActivity: void onResume()>
	3: <org.wordpress.android.WordPressDB: int getThemeCount(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesAtoZ(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.models.Blog: void <init>(int)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadSettings(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesTrending(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaUploadService$1: void run()>
	4: <org.wordpress.android.util.MediaUploadService: android.database.Cursor access$000(org.wordpress.android.util.MediaUploadService)>
	5: <org.wordpress.android.util.MediaUploadService: android.database.Cursor getQueue()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUploadQueue(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.SQLTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePasswords()>

Resource: android.database.Cursor
source method: onLoaderReset()
source file: StatsCursorFragment.java
Our analysis output:
Soot started on Sun May 03 02:05:22 EDT 2020
Soot finished on Sun May 03 02:06:03 EDT 2020
Soot has run for 0 min. 41 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean expandActionView()>
	4: <com.actionbarsherlock.internal.view.menu.MenuBuilder: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	5: <com.actionbarsherlock.internal.widget.ActionBarView$ExpandedActionViewMenuPresenter: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuBuilder,com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	6: <com.actionbarsherlock.widget.SearchView: void onActionViewExpanded()>
	7: <com.actionbarsherlock.widget.SearchView: void setIconified(boolean)>
	8: <com.actionbarsherlock.widget.SearchView: void onSearchClicked()>
	9: <com.actionbarsherlock.widget.SearchView$7: void onClick(android.view.View)>
	10: <com.actionbarsherlock.widget.SearchView: void access$1000(com.actionbarsherlock.widget.SearchView)>
	11: <com.actionbarsherlock.widget.SearchView: void onSubmitQuery()>
	12: <org.wordpress.android.ui.themes.ThemeSearchFragment: boolean onQueryTextSubmit(java.lang.String)>
	13: <org.wordpress.android.ui.themes.ThemeSearchFragment: void search(java.lang.String)>
	14: <org.wordpress.android.WordPressDB: android.database.Cursor getThemes(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesPopularity(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.media.MediaEditFragment: void loadMedia(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFile(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migrateWPComAccount()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaImagesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.AddQuickPressShortcutActivity dummyMainMethod_org_wordpress_android_ui_AddQuickPressShortcutActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.AddQuickPressShortcutActivity: void onActivityResult(int,int,android.content.Intent)>
	3: <org.wordpress.android.WordPressDB: java.util.List getAccounts()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesNewest(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.view.menu.MenuPopupHelper: void onGlobalLayout()>
	3: <com.actionbarsherlock.internal.widget.IcsSpinner$DropdownPopup: void show()>
	4: <com.actionbarsherlock.internal.widget.IcsSpinner: int measureContentWidth(android.widget.SpinnerAdapter,android.graphics.drawable.Drawable)>
	5: <org.wordpress.android.ui.WPActionBarActivity$MenuAdapter: android.view.View getView(int,android.view.View,android.view.ViewGroup)>
	6: <org.wordpress.android.ui.WPActionBarActivity$CommentsMenuItem: void configureView(android.view.View)>
	7: <org.wordpress.android.models.Blog: int getUnmoderatedCommentCount()>
	8: <org.wordpress.android.WordPressDB: int getUnmoderatedCommentCount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: int getCategoryParentId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUnattachedForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$2: void run()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: void onMediaItemListDownloaded()>
	5: <org.wordpress.android.ui.media.MediaItemFragment: void loadDefaultMedia()>
	6: <org.wordpress.android.ui.media.MediaItemFragment: void loadMedia(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getFirstMediaFileForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.AddCategoryActivity dummyMainMethod_org_wordpress_android_ui_posts_AddCategoryActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.AddCategoryActivity$1: void onClick(android.view.View)>
	3: <org.wordpress.android.WordPressDB: int getCategoryId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: void onPause()>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean collapseActionView()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onMenuItemActionCollapse(com.actionbarsherlock.view.MenuItem)>
	5: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onQueryTextChange(java.lang.String)>
	6: <org.wordpress.android.ui.media.MediaGridFragment: void search(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.WPActionBarActivity$1: void onItemClick(android.widget.AdapterView,android.view.View,int,long)>
	3: <org.wordpress.android.ui.MenuDrawerItem: void selectItem()>
	4: <org.wordpress.android.ui.WPActionBarActivity$ReaderMenuItem: void onSelectItem()>
	5: <org.wordpress.android.WordPressDB: int getWPCOMBlogID()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.posts.PostsActivity: void checkForLocalChanges(boolean)>
	4: <org.wordpress.android.WordPressDB: boolean findLocalChanges()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.comments.CommentsActivity dummyMainMethod_org_wordpress_android_ui_comments_CommentsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.comments.CommentsActivity: void onPostResume()>
	3: <org.wordpress.android.ui.comments.CommentsListFragment: boolean loadComments(boolean,boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadComments(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaDeleteService$1: void run()>
	4: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor access$000(org.wordpress.android.util.MediaDeleteService)>
	5: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor getQueueItem()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaDeleteQueueItem(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.models.Post: void <init>(int,long,boolean)>
	3: <org.wordpress.android.WordPressDB: java.util.List loadPost(int,boolean,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.PostUploadService dummyMainMethod_org_wordpress_android_util_PostUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.PostUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.PostUploadService: void uploadNextPost()>
	4: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Boolean doInBackground(org.wordpress.android.models.Post[])>
	6: <org.wordpress.android.WordPressDB: org.wordpress.android.models.MediaFile getMediaFile(java.lang.String,org.wordpress.android.models.Post)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.lang.String getInterval()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: java.util.List loadCategories(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.util.Map getNotificationOptions()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.accounts.AccountSetupActivity$XMLRPCMethod$1: void run()>
	4: <org.wordpress.android.ui.accounts.AccountSetupActivity$1: void callFinished(java.lang.Object[])>
	5: <org.wordpress.android.WordPressDB: long checkMatch(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.prefs.LicensesActivity dummyMainMethod_org_wordpress_android_ui_prefs_LicensesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaGridFragment$4: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment: void setDateFilter()>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.themes.ThemeBrowserActivity: void onResume()>
	3: <org.wordpress.android.WordPressDB: int getThemeCount(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesAtoZ(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.models.Blog: void <init>(int)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadSettings(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesTrending(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaUploadService$1: void run()>
	4: <org.wordpress.android.util.MediaUploadService: android.database.Cursor access$000(org.wordpress.android.util.MediaUploadService)>
	5: <org.wordpress.android.util.MediaUploadService: android.database.Cursor getQueue()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUploadQueue(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.SQLTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePasswords()>

Resource: android.database.Cursor
source method: search()
source file: ThemeSearchFragment.java
Our analysis output:
Soot started on Sun May 03 02:06:48 EDT 2020
Soot finished on Sun May 03 02:07:28 EDT 2020
Soot has run for 0 min. 40 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean expandActionView()>
	4: <com.actionbarsherlock.internal.view.menu.MenuBuilder: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	5: <com.actionbarsherlock.internal.widget.ActionBarView$ExpandedActionViewMenuPresenter: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuBuilder,com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	6: <com.actionbarsherlock.widget.SearchView: void onActionViewExpanded()>
	7: <com.actionbarsherlock.widget.SearchView: void setIconified(boolean)>
	8: <com.actionbarsherlock.widget.SearchView: void onSearchClicked()>
	9: <com.actionbarsherlock.widget.SearchView$7: void onClick(android.view.View)>
	10: <com.actionbarsherlock.widget.SearchView: void access$1000(com.actionbarsherlock.widget.SearchView)>
	11: <com.actionbarsherlock.widget.SearchView: void onSubmitQuery()>
	12: <org.wordpress.android.ui.themes.ThemeSearchFragment: boolean onQueryTextSubmit(java.lang.String)>
	13: <org.wordpress.android.ui.themes.ThemeSearchFragment: void search(java.lang.String)>
	14: <org.wordpress.android.WordPressDB: android.database.Cursor getThemes(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesPopularity(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.media.MediaEditFragment: void loadMedia(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFile(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migrateWPComAccount()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaImagesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.AddQuickPressShortcutActivity dummyMainMethod_org_wordpress_android_ui_AddQuickPressShortcutActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.AddQuickPressShortcutActivity: void onActivityResult(int,int,android.content.Intent)>
	3: <org.wordpress.android.WordPressDB: java.util.List getAccounts()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesNewest(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.view.menu.MenuPopupHelper: void onGlobalLayout()>
	3: <com.actionbarsherlock.internal.widget.IcsSpinner$DropdownPopup: void show()>
	4: <com.actionbarsherlock.internal.widget.IcsSpinner: int measureContentWidth(android.widget.SpinnerAdapter,android.graphics.drawable.Drawable)>
	5: <org.wordpress.android.ui.WPActionBarActivity$MenuAdapter: android.view.View getView(int,android.view.View,android.view.ViewGroup)>
	6: <org.wordpress.android.ui.WPActionBarActivity$CommentsMenuItem: void configureView(android.view.View)>
	7: <org.wordpress.android.models.Blog: int getUnmoderatedCommentCount()>
	8: <org.wordpress.android.WordPressDB: int getUnmoderatedCommentCount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: int getCategoryParentId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUnattachedForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$2: void run()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: void onMediaItemListDownloaded()>
	5: <org.wordpress.android.ui.media.MediaItemFragment: void loadDefaultMedia()>
	6: <org.wordpress.android.ui.media.MediaItemFragment: void loadMedia(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getFirstMediaFileForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.AddCategoryActivity dummyMainMethod_org_wordpress_android_ui_posts_AddCategoryActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.AddCategoryActivity$1: void onClick(android.view.View)>
	3: <org.wordpress.android.WordPressDB: int getCategoryId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: void onPause()>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean collapseActionView()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onMenuItemActionCollapse(com.actionbarsherlock.view.MenuItem)>
	5: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onQueryTextChange(java.lang.String)>
	6: <org.wordpress.android.ui.media.MediaGridFragment: void search(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.WPActionBarActivity$1: void onItemClick(android.widget.AdapterView,android.view.View,int,long)>
	3: <org.wordpress.android.ui.MenuDrawerItem: void selectItem()>
	4: <org.wordpress.android.ui.WPActionBarActivity$ReaderMenuItem: void onSelectItem()>
	5: <org.wordpress.android.WordPressDB: int getWPCOMBlogID()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.posts.PostsActivity: void checkForLocalChanges(boolean)>
	4: <org.wordpress.android.WordPressDB: boolean findLocalChanges()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.comments.CommentsActivity dummyMainMethod_org_wordpress_android_ui_comments_CommentsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.comments.CommentsActivity: void onPostResume()>
	3: <org.wordpress.android.ui.comments.CommentsListFragment: boolean loadComments(boolean,boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadComments(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaDeleteService$1: void run()>
	4: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor access$000(org.wordpress.android.util.MediaDeleteService)>
	5: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor getQueueItem()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaDeleteQueueItem(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.models.Post: void <init>(int,long,boolean)>
	3: <org.wordpress.android.WordPressDB: java.util.List loadPost(int,boolean,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.PostUploadService dummyMainMethod_org_wordpress_android_util_PostUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.PostUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.PostUploadService: void uploadNextPost()>
	4: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Boolean doInBackground(org.wordpress.android.models.Post[])>
	6: <org.wordpress.android.WordPressDB: org.wordpress.android.models.MediaFile getMediaFile(java.lang.String,org.wordpress.android.models.Post)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.lang.String getInterval()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: java.util.List loadCategories(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.util.Map getNotificationOptions()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.accounts.AccountSetupActivity$XMLRPCMethod$1: void run()>
	4: <org.wordpress.android.ui.accounts.AccountSetupActivity$1: void callFinished(java.lang.Object[])>
	5: <org.wordpress.android.WordPressDB: long checkMatch(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.prefs.LicensesActivity dummyMainMethod_org_wordpress_android_ui_prefs_LicensesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaGridFragment$4: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment: void setDateFilter()>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.themes.ThemeBrowserActivity: void onResume()>
	3: <org.wordpress.android.WordPressDB: int getThemeCount(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesAtoZ(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.models.Blog: void <init>(int)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadSettings(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesTrending(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaUploadService$1: void run()>
	4: <org.wordpress.android.util.MediaUploadService: android.database.Cursor access$000(org.wordpress.android.util.MediaUploadService)>
	5: <org.wordpress.android.util.MediaUploadService: android.database.Cursor getQueue()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUploadQueue(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.SQLTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePasswords()>

Resource: android.database.Cursor
source method: refresh()
source file: ThemeTabFragment.java
Our analysis output:
Soot started on Sun May 03 02:08:12 EDT 2020
Soot finished on Sun May 03 02:08:52 EDT 2020
Soot has run for 0 min. 40 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean expandActionView()>
	4: <com.actionbarsherlock.internal.view.menu.MenuBuilder: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	5: <com.actionbarsherlock.internal.widget.ActionBarView$ExpandedActionViewMenuPresenter: boolean expandItemActionView(com.actionbarsherlock.internal.view.menu.MenuBuilder,com.actionbarsherlock.internal.view.menu.MenuItemImpl)>
	6: <com.actionbarsherlock.widget.SearchView: void onActionViewExpanded()>
	7: <com.actionbarsherlock.widget.SearchView: void setIconified(boolean)>
	8: <com.actionbarsherlock.widget.SearchView: void onSearchClicked()>
	9: <com.actionbarsherlock.widget.SearchView$7: void onClick(android.view.View)>
	10: <com.actionbarsherlock.widget.SearchView: void access$1000(com.actionbarsherlock.widget.SearchView)>
	11: <com.actionbarsherlock.widget.SearchView: void onSubmitQuery()>
	12: <org.wordpress.android.ui.themes.ThemeSearchFragment: boolean onQueryTextSubmit(java.lang.String)>
	13: <org.wordpress.android.ui.themes.ThemeSearchFragment: void search(java.lang.String)>
	14: <org.wordpress.android.WordPressDB: android.database.Cursor getThemes(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesPopularity(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.media.MediaEditFragment: void loadMedia(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFile(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migrateWPComAccount()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaImagesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.AddQuickPressShortcutActivity dummyMainMethod_org_wordpress_android_ui_AddQuickPressShortcutActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.AddQuickPressShortcutActivity: void onActivityResult(int,int,android.content.Intent)>
	3: <org.wordpress.android.WordPressDB: java.util.List getAccounts()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadDrafts()>
	5: <org.wordpress.android.WordPressDB: java.util.List loadDrafts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesNewest(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.view.menu.MenuPopupHelper: void onGlobalLayout()>
	3: <com.actionbarsherlock.internal.widget.IcsSpinner$DropdownPopup: void show()>
	4: <com.actionbarsherlock.internal.widget.IcsSpinner: int measureContentWidth(android.widget.SpinnerAdapter,android.graphics.drawable.Drawable)>
	5: <org.wordpress.android.ui.WPActionBarActivity$MenuAdapter: android.view.View getView(int,android.view.View,android.view.ViewGroup)>
	6: <org.wordpress.android.ui.WPActionBarActivity$CommentsMenuItem: void configureView(android.view.View)>
	7: <org.wordpress.android.models.Blog: int getUnmoderatedCommentCount()>
	8: <org.wordpress.android.WordPressDB: int getUnmoderatedCommentCount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: int getCategoryParentId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUnattachedForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$2: void run()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: void onMediaItemListDownloaded()>
	5: <org.wordpress.android.ui.media.MediaItemFragment: void loadDefaultMedia()>
	6: <org.wordpress.android.ui.media.MediaItemFragment: void loadMedia(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getFirstMediaFileForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.AddCategoryActivity dummyMainMethod_org_wordpress_android_ui_posts_AddCategoryActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.AddCategoryActivity$1: void onClick(android.view.View)>
	3: <org.wordpress.android.WordPressDB: int getCategoryId(int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.media.MediaBrowserActivity dummyMainMethod_org_wordpress_android_ui_media_MediaBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaBrowserActivity: void onPause()>
	3: <com.actionbarsherlock.internal.view.menu.MenuItemImpl: boolean collapseActionView()>
	4: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onMenuItemActionCollapse(com.actionbarsherlock.view.MenuItem)>
	5: <org.wordpress.android.ui.media.MediaBrowserActivity: boolean onQueryTextChange(java.lang.String)>
	6: <org.wordpress.android.ui.media.MediaGridFragment: void search(java.lang.String)>
	7: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsReferrersTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.WPActionBarActivity$1: void onItemClick(android.widget.AdapterView,android.view.View,int,long)>
	3: <org.wordpress.android.ui.MenuDrawerItem: void selectItem()>
	4: <org.wordpress.android.ui.WPActionBarActivity$ReaderMenuItem: void onSelectItem()>
	5: <org.wordpress.android.WordPressDB: int getWPCOMBlogID()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopAuthorsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment$3$1: void run()>
	4: <org.wordpress.android.ui.media.MediaGridFragment: void setFilter(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	5: <org.wordpress.android.ui.media.MediaGridFragment: android.database.Cursor filterItems(org.wordpress.android.ui.media.MediaGridFragment$Filter)>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity: boolean onOptionsItemSelected(com.actionbarsherlock.view.MenuItem)>
	3: <org.wordpress.android.ui.posts.PostsActivity: void checkForLocalChanges(boolean)>
	4: <org.wordpress.android.WordPressDB: boolean findLocalChanges()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.comments.CommentsActivity dummyMainMethod_org_wordpress_android_ui_comments_CommentsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.comments.CommentsActivity: void onPostResume()>
	3: <org.wordpress.android.ui.comments.CommentsListFragment: boolean loadComments(boolean,boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadComments(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsGeoviewsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaDeleteService$1: void run()>
	4: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor access$000(org.wordpress.android.util.MediaDeleteService)>
	5: <org.wordpress.android.util.MediaDeleteService: android.database.Cursor getQueueItem()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaDeleteQueueItem(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsTopPostsAndPagesTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.models.Post: void <init>(int,long,boolean)>
	3: <org.wordpress.android.WordPressDB: java.util.List loadPost(int,boolean,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.PostUploadService dummyMainMethod_org_wordpress_android_util_PostUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.PostUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.PostUploadService: void uploadNextPost()>
	4: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Object doInBackground(java.lang.Object[])>
	5: <org.wordpress.android.util.PostUploadService$UploadPostTask: java.lang.Boolean doInBackground(org.wordpress.android.models.Post[])>
	6: <org.wordpress.android.WordPressDB: org.wordpress.android.models.MediaFile getMediaFile(java.lang.String,org.wordpress.android.models.Post)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.lang.String getInterval()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.PostsActivity dummyMainMethod_org_wordpress_android_ui_posts_PostsActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.PostsActivity$7: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.posts.PostsListFragment: boolean loadPosts(boolean)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadUploadedPosts(int,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void populateOrFetchCategories()>
	4: <org.wordpress.android.models.CategoryNode: org.wordpress.android.models.CategoryNode createCategoryTreeFromDB(int)>
	5: <org.wordpress.android.WordPressDB: java.util.List loadCategories(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePreferences(android.content.Context)>
	4: <org.wordpress.android.WordPressDB: java.util.Map getNotificationOptions()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsVideosTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.ui.accounts.AccountSetupActivity$XMLRPCMethod$1: void run()>
	4: <org.wordpress.android.ui.accounts.AccountSetupActivity$1: void callFinished(java.lang.Object[])>
	5: <org.wordpress.android.WordPressDB: long checkMatch(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.prefs.LicensesActivity dummyMainMethod_org_wordpress_android_ui_prefs_LicensesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.media.MediaGridFragment$4: void onClick(android.content.DialogInterface,int)>
	3: <org.wordpress.android.ui.media.MediaGridFragment: void setDateFilter()>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaFilesForBlog(java.lang.String,long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.themes.ThemeBrowserActivity: void onResume()>
	3: <org.wordpress.android.WordPressDB: int getThemeCount(java.lang.String)>
	4: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesAtoZ(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.posts.SelectCategoriesActivity dummyMainMethod_org_wordpress_android_ui_posts_SelectCategoriesActivity(android.content.Intent)>
	2: <org.wordpress.android.ui.posts.SelectCategoriesActivity: void onCreate(android.os.Bundle)>
	3: <org.wordpress.android.models.Blog: void <init>(int)>
	4: <org.wordpress.android.WordPressDB: java.util.List loadSettings(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.ui.themes.ThemeBrowserActivity dummyMainMethod_org_wordpress_android_ui_themes_ThemeBrowserActivity(android.content.Intent)>
	2: <dummyMainClass: org.wordpress.android.ui.themes.ThemeTabFragment dummyMainMethod_org_wordpress_android_ui_themes_ThemeTabFragment(android.content.Intent,android.app.Activity)>
	3: <org.wordpress.android.ui.themes.ThemeTabFragment: void onActivityCreated(android.os.Bundle)>
	4: <org.wordpress.android.ui.themes.ThemeTabFragment: android.database.Cursor fetchThemes(org.wordpress.android.ui.themes.ThemeTabFragment$ThemeSortType)>
	5: <org.wordpress.android.WordPressDB: android.database.Cursor getThemesTrending(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.util.MediaUploadService dummyMainMethod_org_wordpress_android_util_MediaUploadService(android.content.Intent)>
	2: <org.wordpress.android.util.MediaUploadService: void onStart(android.content.Intent,int)>
	3: <org.wordpress.android.util.MediaUploadService$1: void run()>
	4: <org.wordpress.android.util.MediaUploadService: android.database.Cursor access$000(org.wordpress.android.util.MediaUploadService)>
	5: <org.wordpress.android.util.MediaUploadService: android.database.Cursor getQueue()>
	6: <org.wordpress.android.WordPressDB: android.database.Cursor getMediaUploadQueue(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.SQLTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsSearchEngineTermsTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.wordpress.android.providers.StatsContentProvider dummyMainMethod_org_wordpress_android_providers_StatsContentProvider(android.content.Intent)>
	2: <org.wordpress.android.providers.StatsContentProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <org.wordpress.android.datasets.StatsClicksTable: android.database.Cursor query(android.database.sqlite.SQLiteDatabase,android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <org.wordpress.android.WordPress: void onCreate()>
	2: <org.wordpress.android.WordPressDB: void <init>(android.content.Context)>
	3: <org.wordpress.android.WordPressDB: void migratePasswords()>

File does not exist: ./DroidLeaks/apps/Wordpress-rev-4252d9ea21.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-4252d9ea21.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-4252d9ea21.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-4252d9ea21.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-4252d9ea21.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-4252d9ea21.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-4252d9ea21.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-50bf44a3b2.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-50bf44a3b2.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-58273a4124.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-4c554fd6c0.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-035f127679.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-a1a2c7f761.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-975f1c3511.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-0e7026d7cf.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-f4d4acc464.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-4482c3e66d.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-b0a731606d.apk
Resource: android.database.Cursor
source method: bindChat()
source file: ChatView.java
Our analysis output:
Soot started on Sun May 03 02:09:36 EDT 2020
Soot finished on Sun May 03 02:10:29 EDT 2020
Soot has run for 0 min. 53 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onInviteError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onInviteError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession getChatSession(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession getChatSession(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: boolean isDefault()>
SINK:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: boolean isDefault()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.ISubscriptionListener$Stub$Proxy: void onSubscriptionApproved(info.guardianproject.otr.app.im.engine.Contact,long,long)>
SINK:
	<info.guardianproject.otr.app.im.ISubscriptionListener$Stub$Proxy: void onSubscriptionApproved(info.guardianproject.otr.app.im.engine.Contact,long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void addConnectionCreatedListener(info.guardianproject.otr.app.im.IConnectionCreationListener)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void addConnectionCreatedListener(info.guardianproject.otr.app.im.IConnectionCreationListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissChatNotification(long,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissChatNotification(long,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void logout()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void logout()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void offerData(java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void offerData(java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: info.guardianproject.otr.app.im.IContactList getContactList(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: info.guardianproject.otr.app.im.IContactList getContactList(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IChatSessionManager getChatSessionManager()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IChatSessionManager getChatSessionManager()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void leave()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void leave()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void enableDebugLogging(boolean)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void enableDebugLogging(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: java.util.List getActiveConnections()>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: java.util.List getActiveConnections()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.ISubscriptionListener$Stub$Proxy: void onSubScriptionRequest(info.guardianproject.otr.app.im.engine.Contact,long,long)>
SINK:
	<info.guardianproject.otr.app.im.ISubscriptionListener$Stub$Proxy: void onSubScriptionRequest(info.guardianproject.otr.app.im.engine.Contact,long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: info.guardianproject.otr.app.im.IContactList getContactList(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: info.guardianproject.otr.app.im.IContactList getContactList(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void enableDebugLogging(boolean)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void enableDebugLogging(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onSendMessageError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onSendMessageError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.app.im.IImConnection createConnection(long,long)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.app.im.IImConnection createConnection(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferFailed(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferFailed(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.ISubscriptionListener$Stub$Proxy: void onSubscriptionDeclined(info.guardianproject.otr.app.im.engine.Contact,long,long)>
SINK:
	<info.guardianproject.otr.app.im.ISubscriptionListener$Stub$Proxy: void onSubscriptionDeclined(info.guardianproject.otr.app.im.engine.Contact,long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: int getState()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: int getState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int getState()>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int getState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissNotifications(long)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissNotifications(long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: boolean isGroupChatSession()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: boolean isGroupChatSession()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void registerChatListener(info.guardianproject.otr.app.im.IChatListener)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void registerChatListener(info.guardianproject.otr.app.im.IChatListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void registerConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void registerConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: info.guardianproject.otr.app.im.IContactList getContactList(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: info.guardianproject.otr.app.im.IContactList getContactList(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int getState()>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int getState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int removeContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int removeContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int getState()>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int getState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: java.util.List getContactLists()>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: java.util.List getContactLists()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void registerChatListener(info.guardianproject.otr.app.im.IChatListener)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void registerChatListener(info.guardianproject.otr.app.im.IChatListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onStatusChanged(info.guardianproject.otr.app.im.IChatSession)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onStatusChanged(info.guardianproject.otr.app.im.IChatSession)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createMultiUserChatSession(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createMultiUserChatSession(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: java.util.List getContactLists()>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: java.util.List getContactLists()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferComplete(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferComplete(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: long getId()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: long getId()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void approveSubscription(info.guardianproject.otr.app.im.engine.Contact)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void approveSubscription(info.guardianproject.otr.app.im.engine.Contact)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IContactListManager getContactListManager()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IContactListManager getContactListManager()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void offerData(java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void offerData(java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferProgress(boolean,java.lang.String,java.lang.String,java.lang.String,float)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferProgress(boolean,java.lang.String,java.lang.String,java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onSendMessageError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onSendMessageError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferFailed(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferFailed(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IContactListManager getContactListManager()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IContactListManager getContactListManager()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int blockContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int blockContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void registerConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void registerConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: info.guardianproject.otr.app.im.IContactList getContactList(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: info.guardianproject.otr.app.im.IContactList getContactList(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onIncomingReceipt(info.guardianproject.otr.app.im.IChatSession,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onIncomingReceipt(info.guardianproject.otr.app.im.IChatSession,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void setDataListener(info.guardianproject.otr.app.im.IDataListener)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void setDataListener(info.guardianproject.otr.app.im.IDataListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IConnectionCreationListener$Stub$Proxy: void onConnectionCreated(info.guardianproject.otr.app.im.IImConnection)>
SINK:
	<info.guardianproject.otr.app.im.IConnectionCreationListener$Stub$Proxy: void onConnectionCreated(info.guardianproject.otr.app.im.IImConnection)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IChatSessionManager getChatSessionManager()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IChatSessionManager getChatSessionManager()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void approveSubscription(info.guardianproject.otr.app.im.engine.Contact)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void approveSubscription(info.guardianproject.otr.app.im.engine.Contact)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void addConnectionCreatedListener(info.guardianproject.otr.app.im.IConnectionCreationListener)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void addConnectionCreatedListener(info.guardianproject.otr.app.im.IConnectionCreationListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissNotifications(long)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissNotifications(long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferFailed(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferFailed(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void declineSubscription(info.guardianproject.otr.app.im.engine.Contact)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void declineSubscription(info.guardianproject.otr.app.im.engine.Contact)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void inviteContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void inviteContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getAccountId()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getAccountId()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void enableDebugLogging(boolean)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void enableDebugLogging(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void inviteContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void inviteContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: boolean onIncomingMessage(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: boolean onIncomingMessage(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void login(java.lang.String,boolean,boolean)>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void login(java.lang.String,boolean,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: info.guardianproject.otr.IOtrChatSession getOtrChatSession()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: info.guardianproject.otr.IOtrChatSession getOtrChatSession()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IConnectionListener$Stub$Proxy: void onStateChanged(info.guardianproject.otr.app.im.IImConnection,int,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
SINK:
	<info.guardianproject.otr.app.im.IConnectionListener$Stub$Proxy: void onStateChanged(info.guardianproject.otr.app.im.IImConnection,int,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferComplete(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferComplete(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void approveSubscription(info.guardianproject.otr.app.im.engine.Contact)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void approveSubscription(info.guardianproject.otr.app.im.engine.Contact)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getProviderId()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getProviderId()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: boolean isDefault()>
SINK:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: boolean isDefault()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: java.util.List getActiveConnections()>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: java.util.List getActiveConnections()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IContactListManager getContactListManager()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IContactListManager getContactListManager()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void setDataListener(info.guardianproject.otr.app.im.IDataListener)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void setDataListener(info.guardianproject.otr.app.im.IDataListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void logout()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void logout()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onInviteError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onInviteError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void unregisterConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void unregisterConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissChatNotification(long,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissChatNotification(long,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onIncomingReceipt(info.guardianproject.otr.app.im.IChatSession,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onIncomingReceipt(info.guardianproject.otr.app.im.IChatSession,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void logout()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void logout()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IChatSessionManager getChatSessionManager()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IChatSessionManager getChatSessionManager()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onContactError(int,info.guardianproject.otr.app.im.engine.ImErrorInfo,java.lang.String,info.guardianproject.otr.app.im.engine.Contact)>
SINK:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onContactError(int,info.guardianproject.otr.app.im.engine.ImErrorInfo,java.lang.String,info.guardianproject.otr.app.im.engine.Contact)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void leave()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void leave()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onIncomingReceipt(info.guardianproject.otr.app.im.IChatSession,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onIncomingReceipt(info.guardianproject.otr.app.im.IChatSession,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: java.util.List getContactLists()>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: java.util.List getContactLists()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void login(java.lang.String,boolean,boolean)>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void login(java.lang.String,boolean,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: int addContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: int addContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onAllContactListsLoaded()>
SINK:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onAllContactListsLoaded()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.IOtrKeyManager getOtrKeyManager()>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.IOtrKeyManager getOtrKeyManager()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void inviteContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void inviteContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getProviderId()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getProviderId()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: info.guardianproject.otr.IOtrChatSession getOtrChatSession()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: info.guardianproject.otr.IOtrChatSession getOtrChatSession()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createChatSession(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createChatSession(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void login(java.lang.String,boolean,boolean)>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void login(java.lang.String,boolean,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onIncomingReceipt(info.guardianproject.otr.app.im.IChatSession,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onIncomingReceipt(info.guardianproject.otr.app.im.IChatSession,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void addConnectionCreatedListener(info.guardianproject.otr.app.im.IConnectionCreationListener)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void addConnectionCreatedListener(info.guardianproject.otr.app.im.IConnectionCreationListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionListener$Stub$Proxy: void onChatSessionCreateError(java.lang.String,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionListener$Stub$Proxy: void onChatSessionCreateError(java.lang.String,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onInviteError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onInviteError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void leave()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void leave()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onSendMessageError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onSendMessageError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void enableDebugLogging(boolean)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void enableDebugLogging(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onStatusChanged(info.guardianproject.otr.app.im.IChatSession)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onStatusChanged(info.guardianproject.otr.app.im.IChatSession)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: long getId()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: long getId()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionListener$Stub$Proxy: void onChatSessionCreateError(java.lang.String,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionListener$Stub$Proxy: void onChatSessionCreateError(java.lang.String,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: int getState()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: int getState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionListener$Stub$Proxy: void onChatSessionCreated(info.guardianproject.otr.app.im.IChatSession)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionListener$Stub$Proxy: void onChatSessionCreated(info.guardianproject.otr.app.im.IChatSession)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void sendMessage(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void sendMessage(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getProviderId()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getProviderId()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int removeContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int removeContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int removeContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int removeContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void approveSubscription(info.guardianproject.otr.app.im.engine.Contact)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void approveSubscription(info.guardianproject.otr.app.im.engine.Contact)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissNotifications(long)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissNotifications(long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onStatusChanged(info.guardianproject.otr.app.im.IChatSession)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onStatusChanged(info.guardianproject.otr.app.im.IChatSession)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: info.guardianproject.otr.IOtrChatSession getOtrChatSession()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: info.guardianproject.otr.IOtrChatSession getOtrChatSession()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: boolean isDefault()>
SINK:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: boolean isDefault()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void sendMessage(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void sendMessage(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void sendMessage(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void sendMessage(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onContactError(int,info.guardianproject.otr.app.im.engine.ImErrorInfo,java.lang.String,info.guardianproject.otr.app.im.engine.Contact)>
SINK:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onContactError(int,info.guardianproject.otr.app.im.engine.ImErrorInfo,java.lang.String,info.guardianproject.otr.app.im.engine.Contact)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void sendMessage(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void sendMessage(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferProgress(boolean,java.lang.String,java.lang.String,java.lang.String,float)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferProgress(boolean,java.lang.String,java.lang.String,java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IConnectionListener$Stub$Proxy: void onUserPresenceUpdated(info.guardianproject.otr.app.im.IImConnection)>
SINK:
	<info.guardianproject.otr.app.im.IConnectionListener$Stub$Proxy: void onUserPresenceUpdated(info.guardianproject.otr.app.im.IImConnection)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: int addContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: int addContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IConnectionListener$Stub$Proxy: void onUserPresenceUpdated(info.guardianproject.otr.app.im.IImConnection)>
SINK:
	<info.guardianproject.otr.app.im.IConnectionListener$Stub$Proxy: void onUserPresenceUpdated(info.guardianproject.otr.app.im.IImConnection)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.ISubscriptionListener$Stub$Proxy: void onSubScriptionRequest(info.guardianproject.otr.app.im.engine.Contact,long,long)>
SINK:
	<info.guardianproject.otr.app.im.ISubscriptionListener$Stub$Proxy: void onSubScriptionRequest(info.guardianproject.otr.app.im.engine.Contact,long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.IOtrKeyManager getOtrKeyManager()>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.IOtrKeyManager getOtrKeyManager()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createMultiUserChatSession(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createMultiUserChatSession(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int setContactName(java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int setContactName(java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void unregisterConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void unregisterConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createChatSession(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createChatSession(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getAccountId()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getAccountId()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: int getState()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: int getState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void offerData(java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void offerData(java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void registerChatListener(info.guardianproject.otr.app.im.IChatListener)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void registerChatListener(info.guardianproject.otr.app.im.IChatListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IConnectionListener$Stub$Proxy: void onStateChanged(info.guardianproject.otr.app.im.IImConnection,int,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
SINK:
	<info.guardianproject.otr.app.im.IConnectionListener$Stub$Proxy: void onStateChanged(info.guardianproject.otr.app.im.IImConnection,int,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferProgress(boolean,java.lang.String,java.lang.String,java.lang.String,float)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferProgress(boolean,java.lang.String,java.lang.String,java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int removeContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int removeContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int blockContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int blockContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissChatNotification(long,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissChatNotification(long,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession getChatSession(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession getChatSession(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: long getId()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: long getId()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void setDataListener(info.guardianproject.otr.app.im.IDataListener)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void setDataListener(info.guardianproject.otr.app.im.IDataListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: boolean isGroupChatSession()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: boolean isGroupChatSession()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissChatNotification(long,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissChatNotification(long,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createMultiUserChatSession(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createMultiUserChatSession(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: boolean onTransferRequested(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: boolean onTransferRequested(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void unregisterConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void unregisterConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onContactChange(int,info.guardianproject.otr.app.im.IContactList,info.guardianproject.otr.app.im.engine.Contact)>
SINK:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onContactChange(int,info.guardianproject.otr.app.im.IContactList,info.guardianproject.otr.app.im.engine.Contact)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: boolean onTransferRequested(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: boolean onTransferRequested(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.app.im.IImConnection createConnection(long,long)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.app.im.IImConnection createConnection(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: java.util.List getContactLists()>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: java.util.List getContactLists()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IConnectionCreationListener$Stub$Proxy: void onConnectionCreated(info.guardianproject.otr.app.im.IImConnection)>
SINK:
	<info.guardianproject.otr.app.im.IConnectionCreationListener$Stub$Proxy: void onConnectionCreated(info.guardianproject.otr.app.im.IImConnection)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createChatSession(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createChatSession(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferProgress(boolean,java.lang.String,java.lang.String,java.lang.String,float)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferProgress(boolean,java.lang.String,java.lang.String,java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: java.util.List getActiveConnections()>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: java.util.List getActiveConnections()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createChatSession(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createChatSession(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissNotifications(long)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void dismissNotifications(long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferComplete(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferComplete(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.IOtrKeyManager getOtrKeyManager()>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.IOtrKeyManager getOtrKeyManager()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onStatusChanged(info.guardianproject.otr.app.im.IChatSession)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onStatusChanged(info.guardianproject.otr.app.im.IChatSession)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void logout()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void logout()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.ISubscriptionListener$Stub$Proxy: void onSubscriptionApproved(info.guardianproject.otr.app.im.engine.Contact,long,long)>
SINK:
	<info.guardianproject.otr.app.im.ISubscriptionListener$Stub$Proxy: void onSubscriptionApproved(info.guardianproject.otr.app.im.engine.Contact,long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: boolean isGroupChatSession()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: boolean isGroupChatSession()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void leave()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void leave()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void addConnectionCreatedListener(info.guardianproject.otr.app.im.IConnectionCreationListener)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: void addConnectionCreatedListener(info.guardianproject.otr.app.im.IConnectionCreationListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: boolean onTransferRequested(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: boolean onTransferRequested(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.ISubscriptionListener$Stub$Proxy: void onSubscriptionDeclined(info.guardianproject.otr.app.im.engine.Contact,long,long)>
SINK:
	<info.guardianproject.otr.app.im.ISubscriptionListener$Stub$Proxy: void onSubscriptionDeclined(info.guardianproject.otr.app.im.engine.Contact,long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int blockContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int blockContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void declineSubscription(info.guardianproject.otr.app.im.engine.Contact)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void declineSubscription(info.guardianproject.otr.app.im.engine.Contact)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void registerConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void registerConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int blockContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int blockContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void declineSubscription(info.guardianproject.otr.app.im.engine.Contact)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void declineSubscription(info.guardianproject.otr.app.im.engine.Contact)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onContactChange(int,info.guardianproject.otr.app.im.IContactList,info.guardianproject.otr.app.im.engine.Contact)>
SINK:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onContactChange(int,info.guardianproject.otr.app.im.IContactList,info.guardianproject.otr.app.im.engine.Contact)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createMultiUserChatSession(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession createMultiUserChatSession(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getProviderId()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getProviderId()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void inviteContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void inviteContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void registerChatListener(info.guardianproject.otr.app.im.IChatListener)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void registerChatListener(info.guardianproject.otr.app.im.IChatListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onContactsPresenceUpdate(info.guardianproject.otr.app.im.engine.Contact[])>
SINK:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onContactsPresenceUpdate(info.guardianproject.otr.app.im.engine.Contact[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: int getState()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: int getState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.IOtrKeyManager getOtrKeyManager()>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.IOtrKeyManager getOtrKeyManager()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.app.im.IImConnection createConnection(long,long)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.app.im.IImConnection createConnection(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onContactsPresenceUpdate(info.guardianproject.otr.app.im.engine.Contact[])>
SINK:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onContactsPresenceUpdate(info.guardianproject.otr.app.im.engine.Contact[])>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: int addContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: int addContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.app.im.IImConnection createConnection(long,long)>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: info.guardianproject.otr.app.im.IImConnection createConnection(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: int addContact(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: int addContact(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: boolean onIncomingMessage(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: boolean onIncomingMessage(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int setContactName(java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int setContactName(java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void registerContactListListener(info.guardianproject.otr.app.im.IContactListListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: info.guardianproject.otr.IOtrChatSession getOtrChatSession()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: info.guardianproject.otr.IOtrChatSession getOtrChatSession()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void offerData(java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void offerData(java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: boolean isGroupChatSession()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: boolean isGroupChatSession()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: boolean onIncomingMessage(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: boolean onIncomingMessage(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: boolean isDefault()>
SINK:
	<info.guardianproject.otr.app.im.IContactList$Stub$Proxy: boolean isDefault()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferFailed(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferFailed(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void login(java.lang.String,boolean,boolean)>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void login(java.lang.String,boolean,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void registerConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void registerConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void unregisterSubscriptionListener(info.guardianproject.otr.app.im.ISubscriptionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IContactListManager getContactListManager()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IContactListManager getContactListManager()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void declineSubscription(info.guardianproject.otr.app.im.engine.Contact)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: void declineSubscription(info.guardianproject.otr.app.im.engine.Contact)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int setContactName(java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int setContactName(java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionListener$Stub$Proxy: void onChatSessionCreated(info.guardianproject.otr.app.im.IChatSession)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionListener$Stub$Proxy: void onChatSessionCreated(info.guardianproject.otr.app.im.IChatSession)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession getChatSession(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession getChatSession(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void setDataListener(info.guardianproject.otr.app.im.IDataListener)>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: void setDataListener(info.guardianproject.otr.app.im.IDataListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onSendMessageError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onSendMessageError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int getState()>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int getState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IChatSessionManager getChatSessionManager()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: info.guardianproject.otr.app.im.IChatSessionManager getChatSessionManager()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: boolean onTransferRequested(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: boolean onTransferRequested(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: long getId()>
SINK:
	<info.guardianproject.otr.app.im.IChatSession$Stub$Proxy: long getId()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int setContactName(java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IContactListManager$Stub$Proxy: int setContactName(java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void unregisterConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: void unregisterConnectionListener(info.guardianproject.otr.app.im.IConnectionListener)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession getChatSession(java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IChatSessionManager$Stub$Proxy: info.guardianproject.otr.app.im.IChatSession getChatSession(java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getAccountId()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getAccountId()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferComplete(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
SINK:
	<info.guardianproject.otr.app.im.IDataListener$Stub$Proxy: void onTransferComplete(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onInviteError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: void onInviteError(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getAccountId()>
SINK:
	<info.guardianproject.otr.app.im.IImConnection$Stub$Proxy: long getAccountId()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: boolean onIncomingMessage(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message)>
SINK:
	<info.guardianproject.otr.app.im.IChatListener$Stub$Proxy: boolean onIncomingMessage(info.guardianproject.otr.app.im.IChatSession,info.guardianproject.otr.app.im.engine.Message)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: java.util.List getActiveConnections()>
SINK:
	<info.guardianproject.otr.app.im.IRemoteImService$Stub$Proxy: java.util.List getActiveConnections()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onAllContactListsLoaded()>
SINK:
	<info.guardianproject.otr.app.im.IContactListListener$Stub$Proxy: void onAllContactListsLoaded()>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: info.guardianproject.otr.app.im.app.NetworkConnectivityListener dummyMainMethod_info_guardianproject_otr_app_im_app_NetworkConnectivityListener(android.content.Intent)>
	2: <info.guardianproject.otr.app.im.app.NetworkConnectivityListener: void onReceive(android.content.Context,android.content.Intent)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: info.guardianproject.otr.app.im.app.SignoutActivity dummyMainMethod_info_guardianproject_otr_app_im_app_SignoutActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.widget.IcsListPopupWindow$PopupTouchInterceptor: boolean onTouch(android.view.View,android.view.MotionEvent)>
	3: <android.os.Handler: boolean postDelayed(java.lang.Runnable,long)>
	4: <org.jivesoftware.smack.PacketReader$ListenerNotification: void run()>
	5: <org.jivesoftware.smack.Connection$ListenerWrapper: void notifyListener(org.jivesoftware.smack.packet.Packet)>
	6: <info.guardianproject.otr.app.im.plugin.xmpp.XmppConnection$4: void processPacket(org.jivesoftware.smack.packet.Packet)>
	7: <info.guardianproject.otr.app.im.engine.ChatSession: boolean onReceiveMessage(info.guardianproject.otr.app.im.engine.Message)>
	8: <info.guardianproject.otr.OtrChatListener: boolean onIncomingMessage(info.guardianproject.otr.app.im.engine.ChatSession,info.guardianproject.otr.app.im.engine.Message)>
	9: <info.guardianproject.otr.app.im.service.ChatSessionAdapter$ListenerAdapter: void onIncomingDataResponse(info.guardianproject.otr.app.im.engine.ChatSession,info.guardianproject.otr.app.im.engine.Message,byte[])>
	10: <info.guardianproject.otr.OtrDataHandler: void onIncomingResponse(info.guardianproject.otr.app.im.engine.Address,info.guardianproject.otr.app.im.engine.Address,byte[])>
	11: <info.guardianproject.otr.app.im.app.ChatView$DataAdapter: void onTransferFailed(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,int,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: info.guardianproject.otr.app.im.app.SignoutActivity dummyMainMethod_info_guardianproject_otr_app_im_app_SignoutActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.widget.IcsListPopupWindow$PopupTouchInterceptor: boolean onTouch(android.view.View,android.view.MotionEvent)>
	3: <android.os.Handler: boolean postDelayed(java.lang.Runnable,long)>
	4: <info.guardianproject.otr.app.im.app.adapter.ConnectionListenerAdapter$2: void run()>
	5: <info.guardianproject.otr.app.im.app.ImApp$MyConnListener: void onUpdateSelfPresenceError(info.guardianproject.otr.app.im.IImConnection,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
	6: <info.guardianproject.otr.app.im.app.ImApp: void broadcastConnEvent(int,long,info.guardianproject.otr.app.im.engine.ImErrorInfo)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: info.guardianproject.otr.app.im.app.SignoutActivity dummyMainMethod_info_guardianproject_otr_app_im_app_SignoutActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.widget.IcsListPopupWindow$PopupTouchInterceptor: boolean onTouch(android.view.View,android.view.MotionEvent)>
	3: <android.os.Handler: boolean postDelayed(java.lang.Runnable,long)>
	4: <org.jivesoftware.smack.PacketReader$ListenerNotification: void run()>
	5: <org.jivesoftware.smack.Connection$ListenerWrapper: void notifyListener(org.jivesoftware.smack.packet.Packet)>
	6: <info.guardianproject.otr.app.im.plugin.xmpp.XmppConnection$4: void processPacket(org.jivesoftware.smack.packet.Packet)>
	7: <info.guardianproject.otr.app.im.engine.ChatSession: boolean onReceiveMessage(info.guardianproject.otr.app.im.engine.Message)>
	8: <info.guardianproject.otr.OtrChatListener: boolean onIncomingMessage(info.guardianproject.otr.app.im.engine.ChatSession,info.guardianproject.otr.app.im.engine.Message)>
	9: <info.guardianproject.otr.app.im.service.ChatSessionAdapter$ListenerAdapter: void onIncomingDataRequest(info.guardianproject.otr.app.im.engine.ChatSession,info.guardianproject.otr.app.im.engine.Message,byte[])>
	10: <info.guardianproject.otr.OtrDataHandler: void onIncomingRequest(info.guardianproject.otr.app.im.engine.Address,info.guardianproject.otr.app.im.engine.Address,byte[])>
	11: <info.guardianproject.otr.app.im.app.ChatView$DataAdapter: boolean onTransferRequested(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,int,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: info.guardianproject.otr.app.im.app.SignoutActivity dummyMainMethod_info_guardianproject_otr_app_im_app_SignoutActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.widget.IcsListPopupWindow$PopupTouchInterceptor: boolean onTouch(android.view.View,android.view.MotionEvent)>
	3: <android.os.Handler: boolean postDelayed(java.lang.Runnable,long)>
	4: <info.guardianproject.otr.OtrChatSessionAdapter$1: void run()>
	5: <info.guardianproject.otr.OtrChatManager: net.java.otr4j.session.SessionID startSession(java.lang.String,java.lang.String)>
	6: <info.guardianproject.otr.OtrChatManager: void showError(net.java.otr4j.session.SessionID,java.lang.String)>
	7: <info.guardianproject.otr.OtrEngineHostImpl: void showError(net.java.otr4j.session.SessionID,java.lang.String)>
	8: <info.guardianproject.otr.app.im.service.RemoteImService: void showToast(java.lang.CharSequence,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: info.guardianproject.otr.app.im.app.SignoutActivity dummyMainMethod_info_guardianproject_otr_app_im_app_SignoutActivity(android.content.Intent)>
	2: <info.guardianproject.otr.app.im.app.SignoutActivity: void onCreate(android.os.Bundle)>
	3: <info.guardianproject.otr.app.im.app.ImApp: void callWhenServiceConnected(android.os.Handler,java.lang.Runnable)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: info.guardianproject.otr.app.im.app.SignoutActivity dummyMainMethod_info_guardianproject_otr_app_im_app_SignoutActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.widget.IcsListPopupWindow$PopupTouchInterceptor: boolean onTouch(android.view.View,android.view.MotionEvent)>
	3: <android.os.Handler: boolean postDelayed(java.lang.Runnable,long)>
	4: <org.jivesoftware.smack.PacketReader$ListenerNotification: void run()>
	5: <org.jivesoftware.smack.Connection$ListenerWrapper: void notifyListener(org.jivesoftware.smack.packet.Packet)>
	6: <info.guardianproject.otr.app.im.plugin.xmpp.XmppConnection$4: void processPacket(org.jivesoftware.smack.packet.Packet)>
	7: <info.guardianproject.otr.app.im.engine.ChatSession: boolean onReceiveMessage(info.guardianproject.otr.app.im.engine.Message)>
	8: <info.guardianproject.otr.OtrChatListener: boolean onIncomingMessage(info.guardianproject.otr.app.im.engine.ChatSession,info.guardianproject.otr.app.im.engine.Message)>
	9: <info.guardianproject.otr.app.im.service.ChatSessionAdapter$ListenerAdapter: void onIncomingDataResponse(info.guardianproject.otr.app.im.engine.ChatSession,info.guardianproject.otr.app.im.engine.Message,byte[])>
	10: <info.guardianproject.otr.OtrDataHandler: void onIncomingResponse(info.guardianproject.otr.app.im.engine.Address,info.guardianproject.otr.app.im.engine.Address,byte[])>
	11: <info.guardianproject.otr.app.im.app.ChatView$DataAdapter: void onTransferComplete(boolean,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: info.guardianproject.otr.app.im.app.SignoutActivity dummyMainMethod_info_guardianproject_otr_app_im_app_SignoutActivity(android.content.Intent)>
	2: <com.actionbarsherlock.internal.widget.IcsListPopupWindow$PopupTouchInterceptor: boolean onTouch(android.view.View,android.view.MotionEvent)>
	3: <android.os.Handler: boolean postDelayed(java.lang.Runnable,long)>
	4: <org.jivesoftware.smack.PacketReader$ListenerNotification: void run()>
	5: <org.jivesoftware.smack.Connection$ListenerWrapper: void notifyListener(org.jivesoftware.smack.packet.Packet)>
	6: <info.guardianproject.otr.app.im.plugin.xmpp.XmppConnection$4: void processPacket(org.jivesoftware.smack.packet.Packet)>
	7: <info.guardianproject.otr.app.im.engine.ChatSession: boolean onReceiveMessage(info.guardianproject.otr.app.im.engine.Message)>
	8: <info.guardianproject.otr.OtrChatListener: boolean onIncomingMessage(info.guardianproject.otr.app.im.engine.ChatSession,info.guardianproject.otr.app.im.engine.Message)>
	9: <info.guardianproject.otr.app.im.service.ChatSessionAdapter$ListenerAdapter: void onIncomingDataResponse(info.guardianproject.otr.app.im.engine.ChatSession,info.guardianproject.otr.app.im.engine.Message,byte[])>
	10: <info.guardianproject.otr.OtrDataHandler: void onIncomingResponse(info.guardianproject.otr.app.im.engine.Address,info.guardianproject.otr.app.im.engine.Address,byte[])>
	11: <info.guardianproject.otr.app.im.app.ChatView$DataAdapter: void onTransferProgress(boolean,java.lang.String,java.lang.String,java.lang.String,float)>

File does not exist: ./DroidLeaks/apps/ChatSecure-rev-dec89faee2.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-187adca1b9.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-788594fe58.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-446ad5c623.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-446ad5c623.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-446ad5c623.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-446ad5c623.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-446ad5c623.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-e6dc310f3e.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-685de9286f.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-d1b67f7a9a.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-89031f61f6.apk
Resource: android.database.Cursor
source method: getAvailableSites() @line 72
source file: SearchHelper.java
Our analysis output:
Soot started on Sun May 03 02:42:59 EDT 2020
Soot finished on Sun May 03 02:43:25 EDT 2020
Soot has run for 0 min. 25 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: android.database.Cursor
source method: search() @line 118
source file: SearchHelper.java
Our analysis output:
Soot started on Sun May 03 02:43:42 EDT 2020
Soot finished on Sun May 03 02:44:08 EDT 2020
Soot has run for 0 min. 26 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

File does not exist: ./DroidLeaks/apps/Ushahidi-rev-5750c01198.apk
File does not exist: ./DroidLeaks/apps/Ushahidi-rev-fad8f4227b.apk
File does not exist: ./DroidLeaks/apps/CSipSimple-rev-d50021f164.apk
Resource: android.database.Cursor
source method: getPhoneNumbers() @line 123
source file: ContactsUtils5.java
Our analysis output:
Soot started on Sun May 03 02:44:25 EDT 2020
Soot finished on Sun May 03 02:44:35 EDT 2020
Soot has run for 0 min. 9 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
SINK:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
SINK:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
SINK:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
SINK:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.EditFilter dummyMainMethod_com_csipsimple_ui_EditFilter(android.content.Intent)>
	2: <com.csipsimple.ui.EditFilter: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.db.DBAdapter: com.csipsimple.models.Filter getFilter(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.EditFilter dummyMainMethod_com_csipsimple_ui_EditFilter(android.content.Intent)>
	2: <com.csipsimple.ui.EditFilter$2: void onClick(android.view.View)>
	3: <com.csipsimple.ui.EditFilter: void access$000(com.csipsimple.ui.EditFilter)>
	4: <com.csipsimple.ui.EditFilter: void saveFilter()>
	5: <com.csipsimple.db.DBAdapter: int getCountFiltersForAccount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.messages.ComposeMessageActivity dummyMainMethod_com_csipsimple_ui_messages_ComposeMessageActivity(android.content.Intent)>
	2: <com.csipsimple.ui.messages.ComposeMessageActivity: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.ui.messages.ComposeMessageActivity: void loadMessageContent()>
	4: <com.csipsimple.db.DBAdapter: android.database.Cursor getConversation(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.AccountsList dummyMainMethod_com_csipsimple_ui_AccountsList(android.content.Intent)>
	2: <com.csipsimple.ui.AccountsList: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.ui.AccountsList: void updateList()>
	4: <com.csipsimple.db.DBAdapter: java.util.List getListAccounts()>
	5: <com.csipsimple.db.DBAdapter: java.util.List getListAccounts(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.messages.ConversationList dummyMainMethod_com_csipsimple_ui_messages_ConversationList(android.content.Intent)>
	2: <com.csipsimple.ui.messages.ConversationList$2: void onClick(android.content.DialogInterface,int)>
	3: <com.csipsimple.ui.messages.ConversationList: void access$000(com.csipsimple.ui.messages.ConversationList)>
	4: <com.csipsimple.ui.messages.ConversationList: void updateAdapter()>
	5: <com.csipsimple.db.DBAdapter: android.database.Cursor getAllConversations()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.SipHome dummyMainMethod_com_csipsimple_ui_SipHome(android.content.Intent)>
	2: <com.csipsimple.ui.SipHome: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.csipsimple.db.DBAdapter: com.csipsimple.api.SipProfile getAccountForWizard(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.CallLog dummyMainMethod_com_csipsimple_ui_CallLog(android.content.Intent)>
	2: <com.csipsimple.ui.CallLog: void onResume()>
	3: <com.csipsimple.ui.CallLog: void updateData(int)>
	4: <com.csipsimple.db.DBAdapter: android.database.Cursor getCallLog(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.wizards.BasePrefsWizard dummyMainMethod_com_csipsimple_wizards_BasePrefsWizard(android.content.Intent)>
	2: <com.csipsimple.wizards.BasePrefsWizard: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.db.DBAdapter: com.csipsimple.api.SipProfile getAccount(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.SipHome dummyMainMethod_com_csipsimple_ui_SipHome(android.content.Intent)>
	2: <com.csipsimple.ui.SipHome: void onResume()>
	3: <com.csipsimple.ui.SipHome: void startSipService()>
	4: <com.csipsimple.ui.SipHome$1: void run()>
	5: <com.csipsimple.ui.SipHome: void access$100(com.csipsimple.ui.SipHome)>
	6: <com.csipsimple.ui.SipHome: void postStartSipService()>
	7: <com.csipsimple.db.DBAdapter: int getNbrOfAccount()>
	8: <com.csipsimple.db.DBAdapter: int getNbrOfAccount(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.service.SipService$ServiceDeviceStateReceiver dummyMainMethod_com_csipsimple_service_SipService$ServiceDeviceStateReceiver(android.content.Intent)>
	2: <com.csipsimple.service.SipService$ServiceDeviceStateReceiver: void onReceive(android.content.Context,android.content.Intent)>
	3: <com.csipsimple.service.SipService$SipServiceExecutor: void execute(java.lang.Runnable)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.AccountFilters dummyMainMethod_com_csipsimple_ui_AccountFilters(android.content.Intent)>
	2: <com.csipsimple.ui.AccountFilters: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.db.DBAdapter: android.database.Cursor getFiltersForAccount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.CallLogsList dummyMainMethod_com_csipsimple_ui_CallLogsList(android.content.Intent)>
	2: <com.csipsimple.ui.CallLogsList: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.db.DBAdapter: android.database.Cursor getAllCallLogs()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.widgets.AccountWidgetProvider dummyMainMethod_com_csipsimple_widgets_AccountWidgetProvider(android.content.Intent)>
	2: <com.csipsimple.widgets.AccountWidgetProvider: void onUpdate(android.content.Context,android.appwidget.AppWidgetManager,int[])>
	3: <com.csipsimple.widgets.AccountWidgetProvider: android.widget.RemoteViews buildUpdate(android.content.Context,int)>
	4: <com.csipsimple.db.DBAdapter: android.content.ContentValues getAccountValues(long)>

Resource: android.database.Cursor
source method: dataUriFromContactUri() @line 303
source file: ContactHelper.java (line 309)
Our analysis output:
Soot started on Sun May 03 02:44:43 EDT 2020
Soot finished on Sun May 03 02:45:26 EDT 2020
Soot has run for 0 min. 43 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.sufficientlysecure.keychain.util.ParcelableFileCache$1: void readNext()>
SINK:
	<org.sufficientlysecure.keychain.util.ParcelableFileCache$1: void readNext()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.sufficientlysecure.keychain.util.ParcelableFileCache: void writeCache(int,java.util.Iterator)>
SINK:
	<org.sufficientlysecure.keychain.util.ParcelableFileCache: void writeCache(int,java.util.Iterator)>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.remote.CryptoInputParcelCacheService dummyMainMethod_org_sufficientlysecure_keychain_remote_CryptoInputParcelCacheService(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.remote.CryptoInputParcelCacheService: int onStartCommand(android.content.Intent,int,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.service.PassphraseCacheService dummyMainMethod_org_sufficientlysecure_keychain_service_PassphraseCacheService(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.service.PassphraseCacheService: int onStartCommand(android.content.Intent,int,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.service.KeychainService dummyMainMethod_org_sufficientlysecure_keychain_service_KeychainService(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.service.KeychainService: int onStartCommand(android.content.Intent,int,int)>
	3: <java.lang.Thread: void run()>
	4: <org.sufficientlysecure.keychain.service.KeychainService$1: void run()>
	5: <org.sufficientlysecure.keychain.service.KeychainService: void serialKeyImport(java.util.ArrayList,java.lang.String,org.sufficientlysecure.keychain.provider.ProviderHelper)>
	6: <org.sufficientlysecure.keychain.service.KeychainService: void sendMessageToHandler(org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,org.sufficientlysecure.keychain.operations.results.OperationResult)>
	7: <org.sufficientlysecure.keychain.service.KeychainService: void sendMessageToHandler(org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,java.lang.Integer,android.os.Bundle)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.ui.ViewKeyActivity dummyMainMethod_org_sufficientlysecure_keychain_ui_ViewKeyActivity(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.ui.ViewKeyActivity: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <org.sufficientlysecure.keychain.service.PassphraseCacheService: org.sufficientlysecure.keychain.util.Passphrase getCachedPassphrase(android.content.Context,long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.provider.KeychainProvider dummyMainMethod_org_sufficientlysecure_keychain_provider_KeychainProvider(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.provider.KeychainProvider: android.net.Uri insert(android.net.Uri,android.content.ContentValues)>
	3: <org.sufficientlysecure.keychain.provider.KeychainProvider: org.sufficientlysecure.keychain.provider.KeychainDatabase getDb()>
	4: <org.sufficientlysecure.keychain.provider.KeychainDatabase: void <init>(android.content.Context)>
	5: <org.sufficientlysecure.keychain.provider.KeychainDatabase: void checkAndImportApg(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.service.KeychainService dummyMainMethod_org_sufficientlysecure_keychain_service_KeychainService(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.service.KeychainService: int onStartCommand(android.content.Intent,int,int)>
	3: <java.lang.Thread: void run()>
	4: <org.sufficientlysecure.keychain.service.KeychainNewService$1: void run()>
	5: <org.sufficientlysecure.keychain.service.KeychainNewService: void access$100(org.sufficientlysecure.keychain.service.KeychainNewService,org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,org.sufficientlysecure.keychain.operations.results.OperationResult)>
	6: <org.sufficientlysecure.keychain.service.KeychainNewService: void sendMessageToHandler(org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,org.sufficientlysecure.keychain.operations.results.OperationResult)>
	7: <org.sufficientlysecure.keychain.service.KeychainNewService: void sendMessageToHandler(org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,java.lang.Integer,android.os.Bundle)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.provider.KeychainProvider dummyMainMethod_org_sufficientlysecure_keychain_provider_KeychainProvider(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.provider.KeychainProvider: android.net.Uri insert(android.net.Uri,android.content.ContentValues)>
	3: <org.sufficientlysecure.keychain.provider.KeychainProvider: org.sufficientlysecure.keychain.provider.KeychainDatabase getDb()>
	4: <org.sufficientlysecure.keychain.provider.KeychainDatabase: void <init>(android.content.Context)>
	5: <org.sufficientlysecure.keychain.provider.KeychainDatabase: void checkAndImportApg(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.provider.TemporaryStorageProvider dummyMainMethod_org_sufficientlysecure_keychain_provider_TemporaryStorageProvider(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.provider.TemporaryStorageProvider: int delete(android.net.Uri,java.lang.String,java.lang.String[])>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.provider.TemporaryStorageProvider dummyMainMethod_org_sufficientlysecure_keychain_provider_TemporaryStorageProvider(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.provider.TemporaryStorageProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>

Resource: android.database.Cursor
source method: writeKeysToMainProfileContact() @line 536
source file: ContactHelper.java (line 572)
Our analysis output:
Soot started on Sun May 03 02:45:54 EDT 2020
Soot finished on Sun May 03 02:46:40 EDT 2020
Soot has run for 0 min. 45 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.sufficientlysecure.keychain.util.ParcelableFileCache$1: void readNext()>
SINK:
	<org.sufficientlysecure.keychain.util.ParcelableFileCache$1: void readNext()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.sufficientlysecure.keychain.util.ParcelableFileCache: void writeCache(int,java.util.Iterator)>
SINK:
	<org.sufficientlysecure.keychain.util.ParcelableFileCache: void writeCache(int,java.util.Iterator)>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.remote.CryptoInputParcelCacheService dummyMainMethod_org_sufficientlysecure_keychain_remote_CryptoInputParcelCacheService(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.remote.CryptoInputParcelCacheService: int onStartCommand(android.content.Intent,int,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.service.PassphraseCacheService dummyMainMethod_org_sufficientlysecure_keychain_service_PassphraseCacheService(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.service.PassphraseCacheService: int onStartCommand(android.content.Intent,int,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.service.KeychainService dummyMainMethod_org_sufficientlysecure_keychain_service_KeychainService(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.service.KeychainService: int onStartCommand(android.content.Intent,int,int)>
	3: <java.lang.Thread: void run()>
	4: <org.sufficientlysecure.keychain.service.KeychainService$1: void run()>
	5: <org.sufficientlysecure.keychain.service.KeychainService: void serialKeyImport(java.util.ArrayList,java.lang.String,org.sufficientlysecure.keychain.provider.ProviderHelper)>
	6: <org.sufficientlysecure.keychain.service.KeychainService: void sendMessageToHandler(org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,org.sufficientlysecure.keychain.operations.results.OperationResult)>
	7: <org.sufficientlysecure.keychain.service.KeychainService: void sendMessageToHandler(org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,java.lang.Integer,android.os.Bundle)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.ui.ViewKeyActivity dummyMainMethod_org_sufficientlysecure_keychain_ui_ViewKeyActivity(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.ui.ViewKeyActivity: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <org.sufficientlysecure.keychain.service.PassphraseCacheService: org.sufficientlysecure.keychain.util.Passphrase getCachedPassphrase(android.content.Context,long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.provider.KeychainProvider dummyMainMethod_org_sufficientlysecure_keychain_provider_KeychainProvider(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.provider.KeychainProvider: android.net.Uri insert(android.net.Uri,android.content.ContentValues)>
	3: <org.sufficientlysecure.keychain.provider.KeychainProvider: org.sufficientlysecure.keychain.provider.KeychainDatabase getDb()>
	4: <org.sufficientlysecure.keychain.provider.KeychainDatabase: void <init>(android.content.Context)>
	5: <org.sufficientlysecure.keychain.provider.KeychainDatabase: void checkAndImportApg(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.service.KeychainService dummyMainMethod_org_sufficientlysecure_keychain_service_KeychainService(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.service.KeychainService: int onStartCommand(android.content.Intent,int,int)>
	3: <java.lang.Thread: void run()>
	4: <org.sufficientlysecure.keychain.service.KeychainNewService$1: void run()>
	5: <org.sufficientlysecure.keychain.service.KeychainNewService: void access$100(org.sufficientlysecure.keychain.service.KeychainNewService,org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,org.sufficientlysecure.keychain.operations.results.OperationResult)>
	6: <org.sufficientlysecure.keychain.service.KeychainNewService: void sendMessageToHandler(org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,org.sufficientlysecure.keychain.operations.results.OperationResult)>
	7: <org.sufficientlysecure.keychain.service.KeychainNewService: void sendMessageToHandler(org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,java.lang.Integer,android.os.Bundle)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.provider.KeychainProvider dummyMainMethod_org_sufficientlysecure_keychain_provider_KeychainProvider(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.provider.KeychainProvider: android.net.Uri insert(android.net.Uri,android.content.ContentValues)>
	3: <org.sufficientlysecure.keychain.provider.KeychainProvider: org.sufficientlysecure.keychain.provider.KeychainDatabase getDb()>
	4: <org.sufficientlysecure.keychain.provider.KeychainDatabase: void <init>(android.content.Context)>
	5: <org.sufficientlysecure.keychain.provider.KeychainDatabase: void checkAndImportApg(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.provider.TemporaryStorageProvider dummyMainMethod_org_sufficientlysecure_keychain_provider_TemporaryStorageProvider(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.provider.TemporaryStorageProvider: int delete(android.net.Uri,java.lang.String,java.lang.String[])>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.provider.TemporaryStorageProvider dummyMainMethod_org_sufficientlysecure_keychain_provider_TemporaryStorageProvider(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.provider.TemporaryStorageProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>

File does not exist: ./DroidLeaks/apps/APG-rev-a45aaa2277.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-03dd89b3f9.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-03dd89b3f9.apk
Resource: android.database.sqlite.SQLiteDatabase
source method: onDestroy()
source file: LibraryService.java
Our analysis output:
Soot started on Sun May 03 02:47:08 EDT 2020
Soot finished on Sun May 03 02:47:25 EDT 2020
Soot has run for 0 min. 17 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-f355183d84.apk
File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-9235be8331.apk
File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-362fa48a25.apk
Resource: android.database.sqlite.SQLiteDatabase
source method: closeAllResources()
source file: AutoDictionary.java
Our analysis output:
Soot started on Sun May 03 02:47:40 EDT 2020
Soot finished on Sun May 03 02:47:48 EDT 2020
Soot has run for 0 min. 7 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

File does not exist: ./DroidLeaks/apps/Osmand-rev-cfbfa188cc.apk
File does not exist: ./DroidLeaks/apps/CallMeter-rev-4fccc09ae9.apk
File does not exist: ./DroidLeaks/apps/ConnectBot-rev-1a2f49f29c.apk
Resource: android.database.sqlite.SQLiteDatabase
source method: onStop() not overriden
source file: PubkeyListActivity.java
Our analysis output:
Soot started on Sun May 03 02:47:55 EDT 2020
Soot finished on Sun May 03 02:48:03 EDT 2020
Soot has run for 0 min. 7 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.connectbot.PubkeyListActivity dummyMainMethod_org_connectbot_PubkeyListActivity(android.content.Intent)>
	2: <org.connectbot.PubkeyListActivity$3$1: void onClick(android.content.DialogInterface,int)>
	3: <org.connectbot.util.PubkeyDatabase: boolean changePassword(long,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.connectbot.HostListActivity dummyMainMethod_org_connectbot_HostListActivity(android.content.Intent)>
	2: <org.connectbot.service.TerminalBridge: void <init>(org.connectbot.service.TerminalManager,java.lang.String,java.lang.String,java.lang.String,int)>
	3: <org.connectbot.util.PubkeyDatabase: android.database.Cursor allPubkeys()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.connectbot.HostListActivity dummyMainMethod_org_connectbot_HostListActivity(android.content.Intent)>
	2: <org.connectbot.service.TerminalBridge: void <init>(org.connectbot.service.TerminalManager,java.lang.String,java.lang.String,java.lang.String,int)>
	3: <org.connectbot.service.TerminalManager: java.lang.String getPostLogin(java.lang.String)>
	4: <org.connectbot.util.HostDatabase: java.lang.String getPostLogin(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.connectbot.PubkeyListActivity dummyMainMethod_org_connectbot_PubkeyListActivity(android.content.Intent)>
	2: <org.connectbot.util.UpdateHelper: void <init>(android.content.Context)>
	3: <java.lang.Thread: void run()>
	4: <org.connectbot.service.TerminalBridge$2: void run()>
	5: <org.connectbot.service.TerminalBridge: void handleAuthentication()>
	6: <org.connectbot.service.PromptHelper: java.lang.String requestStringPrompt(java.lang.String)>
	7: <org.connectbot.service.PromptHelper: java.lang.Object requestPrompt(java.lang.String,java.lang.Object)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.connectbot.HostEditorActivity dummyMainMethod_org_connectbot_HostEditorActivity(android.content.Intent)>
	2: <org.connectbot.HostEditorActivity: void onCreate(android.os.Bundle)>
	3: <org.connectbot.HostEditorActivity$CursorPreferenceHack: void <init>(org.connectbot.HostEditorActivity,java.lang.String,int)>
	4: <org.connectbot.HostEditorActivity$CursorPreferenceHack: void cacheValues()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.connectbot.PubkeyListActivity dummyMainMethod_org_connectbot_PubkeyListActivity(android.content.Intent)>
	2: <org.connectbot.util.UpdateHelper: void <init>(android.content.Context)>
	3: <java.lang.Thread: void run()>
	4: <org.connectbot.util.UpdateHelper: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.connectbot.service.TerminalManager dummyMainMethod_org_connectbot_service_TerminalManager(android.content.Intent)>
	2: <org.connectbot.service.TerminalManager: void onDestroy()>
	3: <org.connectbot.service.TerminalBridge: void disconnect()>
	4: <org.connectbot.service.TerminalManager: void onDisconnected(org.connectbot.service.TerminalBridge)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.connectbot.HostListActivity dummyMainMethod_org_connectbot_HostListActivity(android.content.Intent)>
	2: <org.connectbot.HostListActivity$5: boolean onMenuItemClick(android.view.MenuItem)>
	3: <org.connectbot.HostListActivity: void updateCursor()>
	4: <org.connectbot.util.HostDatabase: android.database.Cursor allHosts(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.connectbot.PubkeyListActivity dummyMainMethod_org_connectbot_PubkeyListActivity(android.content.Intent)>
	2: <org.connectbot.util.UpdateHelper: void <init>(android.content.Context)>
	3: <java.lang.Thread: void run()>
	4: <com.trilead.ssh2.transport.TransportManager$1: void run()>
	5: <com.trilead.ssh2.transport.KexManager: void handleMessage(byte[],int)>
	6: <org.connectbot.service.TerminalBridge$HostKeyVerifier: boolean verifyServerHostKey(java.lang.String,int,java.lang.String,byte[])>
	7: <org.connectbot.util.HostDatabase: com.trilead.ssh2.KnownHosts getKnownHosts()>

File does not exist: ./DroidLeaks/apps/ConnectBot-rev-2cecc0403f.apk
File does not exist: ./DroidLeaks/apps/CSipSimple-rev-1baa62c1a7.apk
Resource: android.hardware.Camera
source method: releaseMediaRecorder()
source file: VideoCamera.java
Our analysis output:
Soot started on Sun May 03 02:48:10 EDT 2020
Soot finished on Sun May 03 02:48:19 EDT 2020
Soot has run for 0 min. 8 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: android.location.LocationListener
source method: onPause() and onDestroy()
source file: CheckinMap.java
Our analysis output:
Soot started on Sun May 03 02:48:28 EDT 2020
Soot finished on Sun May 03 02:48:34 EDT 2020
Soot has run for 0 min. 5 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ushahidi.android.app.ImageCapture: void surfaceCreated(android.view.SurfaceHolder)>
SINK:
	<com.ushahidi.android.app.ImageCapture: void surfaceDestroyed(android.view.SurfaceHolder)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ushahidi.android.app.ImageCapture: void surfaceCreated(android.view.SurfaceHolder)>
SINK:
	<com.ushahidi.android.app.ImageCapture: void surfaceChanged(android.view.SurfaceHolder,int,int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.ushahidi.android.app.ImageCapture: void surfaceCreated(android.view.SurfaceHolder)>
SINK:
	<com.ushahidi.android.app.ImageCapture: void surfaceDestroyed(android.view.SurfaceHolder)>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ushahidi.android.app.DeploymentSearch dummyMainMethod_com_ushahidi_android_app_DeploymentSearch(android.content.Intent)>
	2: <com.ushahidi.android.app.DeploymentSearch: boolean onContextItemSelected(android.view.MenuItem)>
	3: <com.ushahidi.android.app.checkin.ListCheckin$3: void run()>
	4: <com.ushahidi.android.app.checkin.ListCheckin: void showCheckins()>
	5: <com.ushahidi.android.app.checkin.Checkin: void setThumbnail(java.lang.String)>
	6: <com.ushahidi.android.app.checkin.CheckinUtil: java.lang.String getCheckinThumbnail(java.lang.String)>
	7: <com.ushahidi.android.app.data.UshahidiDatabase: android.database.Cursor fetchCheckinsMediaByCheckinId(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ushahidi.android.app.IncidentMap dummyMainMethod_com_ushahidi_android_app_IncidentMap(android.content.Intent)>
	2: <com.ushahidi.android.app.IncidentMap: void onCreate(android.os.Bundle)>
	3: <com.ushahidi.android.app.IncidentMap: java.util.List showIncidents(java.lang.String)>
	4: <com.ushahidi.android.app.data.UshahidiDatabase: android.database.Cursor fetchIncidentsByCategories(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ushahidi.android.app.DeploymentSearch dummyMainMethod_com_ushahidi_android_app_DeploymentSearch(android.content.Intent)>
	2: <com.ushahidi.android.app.DeploymentSearch: boolean onContextItemSelected(android.view.MenuItem)>
	3: <com.ushahidi.android.app.checkin.ListCheckin$3: void run()>
	4: <com.ushahidi.android.app.checkin.ListCheckin: void showCheckins()>
	5: <com.ushahidi.android.app.checkin.Checkin: void setName(java.lang.String)>
	6: <com.ushahidi.android.app.checkin.CheckinUtil: java.lang.String getCheckinUser(java.lang.String)>
	7: <com.ushahidi.android.app.data.UshahidiDatabase: android.database.Cursor fetchUsersById(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ushahidi.android.app.DeploymentSearch dummyMainMethod_com_ushahidi_android_app_DeploymentSearch(android.content.Intent)>
	2: <com.ushahidi.android.app.DeploymentSearch: boolean onContextItemSelected(android.view.MenuItem)>
	3: <com.ushahidi.android.app.ListIncidents$4: void run()>
	4: <com.ushahidi.android.app.ListIncidents: void showCategories()>
	5: <com.ushahidi.android.app.data.UshahidiDatabase: int fetchCategoriesCount()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ushahidi.android.app.UshahidiApplication: void onTerminate()>
	2: <com.ushahidi.android.app.UshahidiApplication: void cleanupImages()>
	3: <com.ushahidi.android.app.data.UshahidiDatabase: android.database.Cursor fetchAllIncidents()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ushahidi.android.app.OfflineIncidentSendReceiver dummyMainMethod_com_ushahidi_android_app_OfflineIncidentSendReceiver(android.content.Intent)>
	2: <com.ushahidi.android.app.OfflineIncidentSendReceiver: void onReceive(android.content.Context,android.content.Intent)>
	3: <com.ushahidi.android.app.OfflineIncidentSendReceiver: boolean postToOnlineAllOfflineIncidents(android.content.Context)>
	4: <com.ushahidi.android.app.data.UshahidiDatabase: android.database.Cursor fetchAllOfflineIncidents()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ushahidi.android.app.DeploymentSearch dummyMainMethod_com_ushahidi_android_app_DeploymentSearch(android.content.Intent)>
	2: <com.ushahidi.android.app.DeploymentSearch: boolean onContextItemSelected(android.view.MenuItem)>
	3: <com.ushahidi.android.app.UshahidiService$1$1: void run()>
	4: <com.ushahidi.android.app.util.Util: void fetchReports(android.content.Context)>
	5: <com.ushahidi.android.app.data.UshahidiDatabase: void addIncidents(java.util.List,boolean)>
	6: <com.ushahidi.android.app.data.UshahidiDatabase: int limitRows(java.lang.String,int,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <com.ushahidi.android.app.UshahidiApplication: void onTerminate()>
	2: <com.ushahidi.android.app.UshahidiApplication: void cleanupImages()>
	3: <com.ushahidi.android.app.data.UshahidiDatabase: android.database.Cursor fetchAllCategories()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.ushahidi.android.app.DeploymentSearch dummyMainMethod_com_ushahidi_android_app_DeploymentSearch(android.content.Intent)>
	2: <com.ushahidi.android.app.DeploymentSearch: boolean onContextItemSelected(android.view.MenuItem)>
	3: <com.ushahidi.android.app.checkin.ListCheckin$3: void run()>
	4: <com.ushahidi.android.app.checkin.ListCheckin: void showCheckins()>
	5: <com.ushahidi.android.app.data.UshahidiDatabase: android.database.Cursor fetchAllCheckins()>

Resource: android.location.LocationListener
source method: onPause() not overidden
source file: SampleMapActivity.java
Our analysis output:
Soot started on Sun May 03 02:48:39 EDT 2020
Soot finished on Sun May 03 02:48:45 EDT 2020
Soot has run for 0 min. 6 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: android.media.MediaPlayer
source method: onPause()
source file: MainActivity.java
Our analysis output:
Soot started on Sun May 03 02:48:50 EDT 2020
Soot finished on Sun May 03 02:49:25 EDT 2020
Soot has run for 0 min. 34 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

File does not exist: ./DroidLeaks/apps/Quran for Android-rev-1f6d216dc8.apk
Resource: android.media.MediaPlayer
source method: surfaceDestroyed()
source file: ImageViewerActivity.java
Our analysis output:
Soot started on Sun May 03 02:50:03 EDT 2020
Soot finished on Sun May 03 02:50:29 EDT 2020
Soot has run for 0 min. 26 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: android.media.MediaPlayer
source method: onPause() not overidden, surfaceDestroyed()
source file: ImageViewerActivity.java
Our analysis output:
Soot started on Sun May 03 02:50:58 EDT 2020
Soot finished on Sun May 03 02:51:25 EDT 2020
Soot has run for 0 min. 26 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: android.net.http.AndroidHttpClient
source method: run() @line 166
source file: QRCodeEncoder.java
Our analysis output:
Soot started on Sun May 03 02:51:54 EDT 2020
Soot finished on Sun May 03 02:52:01 EDT 2020
Soot has run for 0 min. 7 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: android.net.http.AndroidHttpClient
source method: getCookie() @line 283
source file: SearchBookContentsActivity.java
Our analysis output:
Soot started on Sun May 03 02:52:04 EDT 2020
Soot finished on Sun May 03 02:52:10 EDT 2020
Soot has run for 0 min. 5 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: android.net.wifi.WifiManager.WifiLock
source method: removeHandler @line 1690
source file: NetworkConnection.java
Our analysis output:
Soot started on Sun May 03 02:52:13 EDT 2020
Soot finished on Sun May 03 02:52:35 EDT 2020
Soot has run for 0 min. 21 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

File does not exist: ./DroidLeaks/apps/IRCCloud-rev-7d21b09aaa.apk
Resource: android.os.Parcel
source method: testParcel()
source file: ImageTest.java
Our analysis output:
Soot started on Sun May 03 02:52:53 EDT 2020
Soot finished on Sun May 03 02:54:19 EDT 2020
Soot has run for 1 min. 25 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.LogTrackableActivity dummyMainMethod_cgeo_geocaching_LogTrackableActivity(android.content.Intent)>
	2: <cgeo.geocaching.LogTrackableActivity$LoadGeocacheListener: void onFocusChange(android.view.View,boolean)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Geocache loadCache(java.lang.String,java.util.EnumSet)>
	4: <cgeo.geocaching.DataStore: java.util.Set loadCaches(java.util.Collection,java.util.EnumSet)>
	5: <cgeo.geocaching.DataStore: java.util.Set loadCachesFromGeocodes(java.util.Set,java.util.EnumSet)>
	6: <cgeo.geocaching.DataStore: java.util.Map loadLogCounts(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.CompassActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Waypoint loadWaypoint(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheListActivity dummyMainMethod_cgeo_geocaching_CacheListActivity(android.content.Intent)>
	2: <cgeo.geocaching.CacheListActivity: void onResume()>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.SearchResult getBatchOfStoredCaches(cgeo.geocaching.location.Geopoint,cgeo.geocaching.enumerations.CacheType,int)>
	4: <cgeo.geocaching.DataStore: java.util.Set loadBatchOfStoredGeocodes(cgeo.geocaching.location.Geopoint,cgeo.geocaching.enumerations.CacheType,int)>
	5: <cgeo.geocaching.DataStore: java.util.Collection queryToColl(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.util.Collection,rx.functions.Func1)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheDetailActivity dummyMainMethod_cgeo_geocaching_CacheDetailActivity(android.content.Intent)>
	2: <cgeo.geocaching.CacheDetailActivity: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <cgeo.geocaching.utils.CheckerUtils: java.lang.String getCheckerUrl(cgeo.geocaching.Geocache)>
	4: <cgeo.geocaching.Geocache: java.lang.String getDescription()>
	5: <cgeo.geocaching.Geocache: void initializeCacheTexts()>
	6: <cgeo.geocaching.DataStore: cgeo.geocaching.Geocache loadCacheTexts(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.SearchActivity dummyMainMethod_cgeo_geocaching_SearchActivity(android.content.Intent)>
	2: <cgeo.geocaching.SearchActivity$15: void onClick(android.view.View)>
	3: <cgeo.geocaching.files.AbstractFileListActivity$SearchFilesThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.LogCacheActivity dummyMainMethod_cgeo_geocaching_LogCacheActivity(android.content.Intent)>
	2: <cgeo.geocaching.LogCacheActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.LogEntry loadLogOffline(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheListActivity dummyMainMethod_cgeo_geocaching_CacheListActivity(android.content.Intent)>
	2: <cgeo.geocaching.CacheListActivity: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <cgeo.geocaching.CacheListActivity: void renameList()>
	4: <cgeo.geocaching.command.RenameListCommand: void execute()>
	5: <cgeo.geocaching.DataStore: cgeo.geocaching.list.StoredList getList(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.settings.SettingsActivity dummyMainMethod_cgeo_geocaching_settings_SettingsActivity(android.content.Intent)>
	2: <cgeo.geocaching.activity.TokenAuthorizationActivity$StartListener: void onClick(android.view.View)>
	3: <rx.schedulers.ImmediateScheduler$InnerImmediateScheduler: rx.Subscription schedule(rx.functions.Action0)>
	4: <cgeo.geocaching.Geocache$3: void call()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.SearchActivity dummyMainMethod_cgeo_geocaching_SearchActivity(android.content.Intent)>
	2: <cgeo.geocaching.SearchActivity$15: void onClick(android.view.View)>
	3: <cgeo.geocaching.files.AbstractFileListActivity$SearchFilesThread: void run()>
	4: <cgeo.geocaching.utils.FileUtils: void listDir(java.util.List,java.io.File,cgeo.geocaching.utils.FileUtils$FileSelector,android.os.Handler)>
	5: <cgeo.geocaching.utils.FileUtils: void listDirInternally(java.util.List,java.io.File,cgeo.geocaching.utils.FileUtils$FileSelector,android.os.Handler,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.settings.SettingsActivity dummyMainMethod_cgeo_geocaching_settings_SettingsActivity(android.content.Intent)>
	2: <cgeo.geocaching.activity.TokenAuthorizationActivity$StartListener: void onClick(android.view.View)>
	3: <rx.schedulers.ImmediateScheduler$InnerImmediateScheduler: rx.Subscription schedule(rx.functions.Action0)>
	4: <cgeo.geocaching.CacheDetailActivity$2: void call()>
	5: <cgeo.geocaching.Geocache: cgeo.geocaching.SearchResult searchByGeocode(java.lang.String,java.lang.String,int,boolean,cgeo.geocaching.utils.CancellableHandler)>
	6: <cgeo.geocaching.DataStore: boolean isThere(java.lang.String,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.SearchActivity dummyMainMethod_cgeo_geocaching_SearchActivity(android.content.Intent)>
	2: <cgeo.geocaching.SearchActivity$15: void onClick(android.view.View)>
	3: <cgeo.geocaching.EditWaypointActivity$LoadWaypointThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <cgeo.geocaching.CgeoApplication: void onCreate()>
	2: <cgeo.geocaching.DataStore: java.util.List getLists()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.search.SuggestionProvider dummyMainMethod_cgeo_geocaching_search_SuggestionProvider(android.content.Intent)>
	2: <cgeo.geocaching.search.SuggestionProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <cgeo.geocaching.search.SuggestionProvider: android.database.Cursor getSuggestions(java.lang.String)>
	4: <cgeo.geocaching.DataStore: android.database.Cursor findSuggestions(java.lang.String)>
	5: <cgeo.geocaching.DataStore: void findTrackables(android.database.MatrixCursor,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.search.SuggestionProvider dummyMainMethod_cgeo_geocaching_search_SuggestionProvider(android.content.Intent)>
	2: <cgeo.geocaching.search.SuggestionProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <cgeo.geocaching.search.SuggestionProvider: android.database.Cursor getSuggestions(java.lang.String)>
	4: <cgeo.geocaching.DataStore: android.database.Cursor findSuggestions(java.lang.String)>
	5: <cgeo.geocaching.DataStore: void findCaches(cgeo.geocaching.search.SearchSuggestionCursor,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.SearchActivity dummyMainMethod_cgeo_geocaching_SearchActivity(android.content.Intent)>
	2: <cgeo.geocaching.SearchActivity$15: void onClick(android.view.View)>
	3: <cgeo.geocaching.maps.CGeoMap$DoRunnable: void run()>
	4: <cgeo.geocaching.maps.CGeoMap$LoadRunnable: void runWithMap(cgeo.geocaching.maps.CGeoMap)>
	5: <cgeo.geocaching.maps.CGeoMap: void access$2600(cgeo.geocaching.maps.CGeoMap)>
	6: <cgeo.geocaching.maps.CGeoMap: void doLoadRun()>
	7: <cgeo.geocaching.DataStore: java.util.Set loadWaypoints(cgeo.geocaching.location.Viewport,boolean,boolean,cgeo.geocaching.enumerations.CacheType)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.settings.SettingsActivity dummyMainMethod_cgeo_geocaching_settings_SettingsActivity(android.content.Intent)>
	2: <cgeo.geocaching.activity.TokenAuthorizationActivity$StartListener: void onClick(android.view.View)>
	3: <rx.schedulers.ImmediateScheduler$InnerImmediateScheduler: rx.Subscription schedule(rx.functions.Action0)>
	4: <cgeo.geocaching.CacheDetailActivity$2: void call()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.SearchActivity dummyMainMethod_cgeo_geocaching_SearchActivity(android.content.Intent)>
	2: <cgeo.geocaching.SearchActivity$15: void onClick(android.view.View)>
	3: <cgeo.geocaching.files.AbstractFileListActivity$SearchFilesThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.settings.SettingsActivity dummyMainMethod_cgeo_geocaching_settings_SettingsActivity(android.content.Intent)>
	2: <cgeo.geocaching.activity.TokenAuthorizationActivity$StartListener: void onClick(android.view.View)>
	3: <rx.schedulers.ImmediateScheduler$InnerImmediateScheduler: rx.Subscription schedule(rx.functions.Action0)>
	4: <cgeo.geocaching.CacheDetailActivity$2: void call()>
	5: <cgeo.geocaching.Geocache: cgeo.geocaching.SearchResult searchByGeocode(java.lang.String,java.lang.String,int,boolean,cgeo.geocaching.utils.CancellableHandler)>
	6: <cgeo.geocaching.DataStore: boolean isThere(java.lang.String,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.SearchActivity dummyMainMethod_cgeo_geocaching_SearchActivity(android.content.Intent)>
	2: <cgeo.geocaching.SearchActivity$15: void onClick(android.view.View)>
	3: <cgeo.geocaching.files.AbstractFileListActivity$SearchFilesThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.LogTrackableActivity dummyMainMethod_cgeo_geocaching_LogTrackableActivity(android.content.Intent)>
	2: <cgeo.geocaching.LogTrackableActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Trackable loadTrackable(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.LogTrackableActivity dummyMainMethod_cgeo_geocaching_LogTrackableActivity(android.content.Intent)>
	2: <cgeo.geocaching.LogTrackableActivity$LoadGeocacheListener: void onFocusChange(android.view.View,boolean)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Geocache loadCache(java.lang.String,java.util.EnumSet)>
	4: <cgeo.geocaching.DataStore: java.util.Set loadCaches(java.util.Collection,java.util.EnumSet)>
	5: <cgeo.geocaching.DataStore: java.util.Set loadCachesFromGeocodes(java.util.Set,java.util.EnumSet)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.settings.SettingsActivity dummyMainMethod_cgeo_geocaching_settings_SettingsActivity(android.content.Intent)>
	2: <rx.android.content.OnSubscribeSharedPreferenceChange$1: void onSharedPreferenceChanged(android.content.SharedPreferences,java.lang.String)>
	3: <rx.internal.operators.OperatorDistinct$1: void onNext(java.lang.Object)>
	4: <cgeo.geocaching.SearchActivity$6: java.lang.Object call(java.lang.Object)>
	5: <cgeo.geocaching.SearchActivity$6: java.lang.String[] call(java.lang.String)>
	6: <cgeo.geocaching.DataStore: java.lang.String[] getSuggestionsGeocode(java.lang.String)>
	7: <cgeo.geocaching.DataStore: java.lang.String[] getSuggestions(java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.SearchActivity dummyMainMethod_cgeo_geocaching_SearchActivity(android.content.Intent)>
	2: <cgeo.geocaching.SearchActivity$15: void onClick(android.view.View)>
	3: <cgeo.geocaching.StaticMapsActivity$LoadMapsThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.SearchActivity dummyMainMethod_cgeo_geocaching_SearchActivity(android.content.Intent)>
	2: <cgeo.geocaching.SearchActivity$15: void onClick(android.view.View)>
	3: <cgeo.geocaching.maps.CGeoMap$LoadDetails: void run()>
	4: <cgeo.geocaching.Geocache: void storeCache(cgeo.geocaching.Geocache,java.lang.String,int,boolean,cgeo.geocaching.utils.CancellableHandler)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.LogTrackableActivity dummyMainMethod_cgeo_geocaching_LogTrackableActivity(android.content.Intent)>
	2: <cgeo.geocaching.LogTrackableActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Trackable loadTrackable(java.lang.String)>
	4: <cgeo.geocaching.DataStore: cgeo.geocaching.Trackable createTrackableFromDatabaseContent(android.database.Cursor)>
	5: <cgeo.geocaching.DataStore: java.util.List loadLogs(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.LogTrackableActivity dummyMainMethod_cgeo_geocaching_LogTrackableActivity(android.content.Intent)>
	2: <cgeo.geocaching.LogTrackableActivity$LoadGeocacheListener: void onFocusChange(android.view.View,boolean)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Geocache loadCache(java.lang.String,java.util.EnumSet)>
	4: <cgeo.geocaching.DataStore: java.util.Set loadCaches(java.util.Collection,java.util.EnumSet)>
	5: <cgeo.geocaching.DataStore: java.util.Set loadCachesFromGeocodes(java.util.Set,java.util.EnumSet)>
	6: <cgeo.geocaching.DataStore: java.util.List loadInventory(java.lang.String)>

File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-71a8ffc2b5.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-e6132286a0.apk
Resource: android.os.PowerManager.WakeLock
source method: onHandleIntent()
source file: LogRunnerService.java
Our analysis output:
Soot started on Sun May 03 02:57:26 EDT 2020
Soot finished on Sun May 03 02:57:45 EDT 2020
Soot has run for 0 min. 18 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: de.ub0r.android.callmeter.data.DataProvider dummyMainMethod_de_ub0r_android_callmeter_data_DataProvider(android.content.Intent)>
	2: <de.ub0r.android.callmeter.data.DataProvider: int delete(android.net.Uri,java.lang.String,java.lang.String[])>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: de.ub0r.android.callmeter.data.DataProvider dummyMainMethod_de_ub0r_android_callmeter_data_DataProvider(android.content.Intent)>
	2: <de.ub0r.android.callmeter.data.DataProvider: android.net.Uri insert(android.net.Uri,android.content.ContentValues)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: de.ub0r.android.callmeter.ui.AskForPlan dummyMainMethod_de_ub0r_android_callmeter_ui_AskForPlan(android.content.Intent)>
	2: <de.ub0r.android.callmeter.ui.AskForPlan: void onCreate(android.os.Bundle)>
	3: <de.ub0r.android.callmeter.ui.prefs.Preferences$5: java.lang.Object doInBackground(java.lang.Object[])>
	4: <de.ub0r.android.callmeter.ui.prefs.Preferences$5: java.lang.String doInBackground(java.lang.Void[])>
	5: <de.ub0r.android.callmeter.data.DataProvider: java.lang.String backupRuleSet(android.content.Context,java.lang.String)>
	6: <de.ub0r.android.callmeter.data.DataProvider: void backupRuleSetSub(java.lang.StringBuilder,android.database.sqlite.SQLiteDatabase,java.lang.String,java.lang.String[],java.lang.String)>
	7: <de.ub0r.android.callmeter.data.DataProvider: android.content.ContentValues[] backup(android.database.sqlite.SQLiteDatabase,java.lang.String,java.lang.String[],java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.ParcelFileDescriptor: android.os.ParcelFileDescriptor open(java.io.File,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: de.ub0r.android.callmeter.data.DataProvider dummyMainMethod_de_ub0r_android_callmeter_data_DataProvider(android.content.Intent)>
	2: <de.ub0r.android.callmeter.data.DataProvider: android.os.ParcelFileDescriptor openFile(android.net.Uri,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: de.ub0r.android.callmeter.data.DataProvider dummyMainMethod_de_ub0r_android_callmeter_data_DataProvider(android.content.Intent)>
	2: <de.ub0r.android.callmeter.data.DataProvider: android.net.Uri insert(android.net.Uri,android.content.ContentValues)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: de.ub0r.android.callmeter.data.DataProvider dummyMainMethod_de_ub0r_android_callmeter_data_DataProvider(android.content.Intent)>
	2: <de.ub0r.android.callmeter.data.DataProvider: int delete(android.net.Uri,java.lang.String,java.lang.String[])>

File does not exist: ./DroidLeaks/apps/ConnectBot-rev-76c4f80e47.apk
Resource: android.os.PowerManager.WakeLock
source method: updateWakeLock()
source file: GPSLoggerService.java
Our analysis output:
Soot started on Sun May 03 02:57:58 EDT 2020
Soot finished on Sun May 03 02:58:15 EDT 2020
Soot has run for 0 min. 17 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.location.Location getLastWaypoint()>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.location.Location getLastWaypoint()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.net.Uri storeMediaUri(android.net.Uri)>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.net.Uri storeMediaUri(android.net.Uri)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: boolean isMediaPrepared()>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: boolean isMediaPrepared()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: int loggingState()>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: int loggingState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.location.Location getLastWaypoint()>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.location.Location getLastWaypoint()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: boolean isMediaPrepared()>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: boolean isMediaPrepared()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.location.Location getLastWaypoint()>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.location.Location getLastWaypoint()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: boolean isMediaPrepared()>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: boolean isMediaPrepared()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: int loggingState()>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: int loggingState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: int loggingState()>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: int loggingState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: boolean isMediaPrepared()>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: boolean isMediaPrepared()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.net.Uri storeMediaUri(android.net.Uri)>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.net.Uri storeMediaUri(android.net.Uri)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: int loggingState()>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: int loggingState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.location.Location getLastWaypoint()>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.location.Location getLastWaypoint()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.net.Uri storeMediaUri(android.net.Uri)>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.net.Uri storeMediaUri(android.net.Uri)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.net.Uri storeMediaUri(android.net.Uri)>
SINK:
	<nl.sogeti.android.gpstracker.logger.IGPSLoggerServiceRemote$Stub$Proxy: android.net.Uri storeMediaUri(android.net.Uri)>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: nl.sogeti.android.gpstracker.db.GPStrackingProvider dummyMainMethod_nl_sogeti_android_gpstracker_db_GPStrackingProvider(android.content.Intent)>
	2: <nl.sogeti.android.gpstracker.db.GPStrackingProvider: int delete(android.net.Uri,java.lang.String,java.lang.String[])>
	3: <nl.sogeti.android.gpstracker.db.DatabaseHelper: int deleteMedia(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: nl.sogeti.android.gpstracker.logger.GPSLoggerService dummyMainMethod_nl_sogeti_android_gpstracker_logger_GPSLoggerService(android.content.Intent)>
	2: <nl.sogeti.android.gpstracker.logger.GPSLoggerService: void onCreate()>
	3: <nl.sogeti.android.gpstracker.logger.GPSLoggerService: void startLogging()>
	4: <nl.sogeti.android.gpstracker.logger.GPSLoggerService: void sendRequestLocationUpdatesMessage()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: nl.sogeti.android.gpstracker.db.GPStrackingProvider dummyMainMethod_nl_sogeti_android_gpstracker_db_GPStrackingProvider(android.content.Intent)>
	2: <nl.sogeti.android.gpstracker.db.GPStrackingProvider: int delete(android.net.Uri,java.lang.String,java.lang.String[])>
	3: <nl.sogeti.android.gpstracker.db.DatabaseHelper: int deleteTrack(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: nl.sogeti.android.gpstracker.db.GPStrackingProvider dummyMainMethod_nl_sogeti_android_gpstracker_db_GPStrackingProvider(android.content.Intent)>
	2: <nl.sogeti.android.gpstracker.db.GPStrackingProvider: int delete(android.net.Uri,java.lang.String,java.lang.String[])>
	3: <nl.sogeti.android.gpstracker.db.DatabaseHelper: int deleteMetaData(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: nl.sogeti.android.gpstracker.logger.GPSLoggerService dummyMainMethod_nl_sogeti_android_gpstracker_logger_GPSLoggerService(android.content.Intent)>
	2: <nl.sogeti.android.gpstracker.logger.GPSLoggerService: void onDestroy()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: nl.sogeti.android.gpstracker.logger.GPSLoggerService dummyMainMethod_nl_sogeti_android_gpstracker_logger_GPSLoggerService(android.content.Intent)>
	2: <nl.sogeti.android.gpstracker.logger.GPSLoggerService: void onCreate()>
	3: <nl.sogeti.android.gpstracker.logger.GPSLoggerService: void startLogging()>
	4: <nl.sogeti.android.gpstracker.logger.GPSLoggerService: void sendRequestStatusUpdateMessage()>

File does not exist: ./DroidLeaks/apps/VLC-rev-14b18bc27f.apk
Resource: android.os.PowerManager.WakeLock
source method: on_incoming_call()
source file: UAStateReceiver.java
Our analysis output:
Soot started on Sun May 03 02:58:25 EDT 2020
Soot finished on Sun May 03 02:58:39 EDT 2020
Soot has run for 0 min. 14 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
SINK:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
SINK:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
SINK:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
SINK:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.CallLog dummyMainMethod_com_csipsimple_ui_CallLog(android.content.Intent)>
	2: <com.csipsimple.ui.CallLog: void onResume()>
	3: <com.csipsimple.ui.CallLog: void updateData(int)>
	4: <com.csipsimple.db.DBAdapter: android.database.Cursor getCallLog(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.SipHome dummyMainMethod_com_csipsimple_ui_SipHome(android.content.Intent)>
	2: <com.csipsimple.ui.SipHome: void onResume()>
	3: <com.csipsimple.ui.SipHome: void startSipService()>
	4: <com.csipsimple.ui.SipHome$1: void run()>
	5: <com.csipsimple.ui.SipHome: void access$100(com.csipsimple.ui.SipHome)>
	6: <com.csipsimple.ui.SipHome: void postStartSipService()>
	7: <com.csipsimple.db.DBAdapter: int getNbrOfAccount()>
	8: <com.csipsimple.db.DBAdapter: int getNbrOfAccount(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.widgets.AccountWidgetProvider dummyMainMethod_com_csipsimple_widgets_AccountWidgetProvider(android.content.Intent)>
	2: <com.csipsimple.widgets.AccountWidgetProvider: void onUpdate(android.content.Context,android.appwidget.AppWidgetManager,int[])>
	3: <com.csipsimple.widgets.AccountWidgetProvider: android.widget.RemoteViews buildUpdate(android.content.Context,int)>
	4: <com.csipsimple.db.DBAdapter: android.content.ContentValues getAccountValues(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.OutgoingCallChooser dummyMainMethod_com_csipsimple_ui_OutgoingCallChooser(android.content.Intent)>
	2: <com.csipsimple.ui.OutgoingCallChooser: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.ui.OutgoingCallChooser: void checkNumberWithSipStarted()>
	4: <com.csipsimple.db.DBAdapter: java.util.List getListAccounts(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.EditFilter dummyMainMethod_com_csipsimple_ui_EditFilter(android.content.Intent)>
	2: <com.csipsimple.ui.EditFilter: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.db.DBAdapter: com.csipsimple.models.Filter getFilter(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.EditFilter dummyMainMethod_com_csipsimple_ui_EditFilter(android.content.Intent)>
	2: <com.csipsimple.ui.EditFilter$2: void onClick(android.view.View)>
	3: <com.csipsimple.ui.EditFilter: void access$000(com.csipsimple.ui.EditFilter)>
	4: <com.csipsimple.ui.EditFilter: void saveFilter()>
	5: <com.csipsimple.db.DBAdapter: int getCountFiltersForAccount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.CallLogsList dummyMainMethod_com_csipsimple_ui_CallLogsList(android.content.Intent)>
	2: <com.csipsimple.ui.CallLogsList: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.db.DBAdapter: android.database.Cursor getAllCallLogs()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.AccountFilters dummyMainMethod_com_csipsimple_ui_AccountFilters(android.content.Intent)>
	2: <com.csipsimple.ui.AccountFilters: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.db.DBAdapter: com.csipsimple.api.SipProfile getAccount(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.messages.ConversationList dummyMainMethod_com_csipsimple_ui_messages_ConversationList(android.content.Intent)>
	2: <com.csipsimple.ui.messages.ConversationList$2: void onClick(android.content.DialogInterface,int)>
	3: <com.csipsimple.ui.messages.ConversationList: void access$000(com.csipsimple.ui.messages.ConversationList)>
	4: <com.csipsimple.ui.messages.ConversationList: void updateAdapter()>
	5: <com.csipsimple.db.DBAdapter: android.database.Cursor getAllConversations()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.AccountFilters dummyMainMethod_com_csipsimple_ui_AccountFilters(android.content.Intent)>
	2: <com.csipsimple.ui.AccountFilters: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.db.DBAdapter: android.database.Cursor getFiltersForAccount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.service.SipService dummyMainMethod_com_csipsimple_service_SipService(android.content.Intent)>
	2: <com.csipsimple.service.SipService$ServicePhoneStateReceiver: void onCallStateChanged(int,java.lang.String)>
	3: <com.csipsimple.service.SipService$SipServiceExecutor: void execute(java.lang.Runnable)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.SipHome dummyMainMethod_com_csipsimple_ui_SipHome(android.content.Intent)>
	2: <com.csipsimple.ui.SipHome: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.csipsimple.db.DBAdapter: com.csipsimple.api.SipProfile getAccountForWizard(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.messages.ComposeMessageActivity dummyMainMethod_com_csipsimple_ui_messages_ComposeMessageActivity(android.content.Intent)>
	2: <com.csipsimple.ui.messages.ComposeMessageActivity: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.ui.messages.ComposeMessageActivity: void loadMessageContent()>
	4: <com.csipsimple.db.DBAdapter: android.database.Cursor getConversation(java.lang.String)>

File does not exist: ./DroidLeaks/apps/CSipSimple-rev-bf79346fcb.apk
Resource: android.os.PowerManager.WakeLock
source method: realRun() @line 803
source file: SipService.java
Our analysis output:
Soot started on Sun May 03 02:58:50 EDT 2020
Soot finished on Sun May 03 02:59:05 EDT 2020
Soot has run for 0 min. 14 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
SINK:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void adjustVolume(com.csipsimple.api.SipCallSession,int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
SINK:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setAccountRegistration(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int reinvite(int,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
SINK:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hangup(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void makeCall(java.lang.String,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: boolean canRecord(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: long addOrUpdateAccount(com.csipsimple.api.SipProfile)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int answer(int,int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceBoolean(java.lang.String,boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.SipProfileState getSipProfileState(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: void registerCallback(com.csipsimple.service.IDownloadLibServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void forceStopService()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
SINK:
	<com.csipsimple.service.IDownloadLibServiceCallback$Stub$Proxy: void updateDownloadProgress(long,long)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setEchoCancellation(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: boolean isDownloadRunning()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
SINK:
	<com.csipsimple.api.ISipConfiguration$Stub$Proxy: void setPreferenceFloat(java.lang.String,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
SINK:
	<com.csipsimple.service.IDownloadLibService$Stub$Proxy: com.csipsimple.models.RemoteLibInfo getCurrentRemoteLib()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int hold(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustTxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: com.csipsimple.api.MediaState getCurrentMediaState()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void askThreadedRestart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void startRecording(int)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setMicrophoneMute(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int xfer(int,java.lang.String)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setBluetoothOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void setSpeakerphoneOn(boolean)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sipStart()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: int getRecordedCall()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void reAddAllAccounts()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void confAdjustRxLevel(int,float)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
SINK:
	<com.csipsimple.api.ISipService$Stub$Proxy: void sendMessage(java.lang.String,java.lang.String,int)>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.messages.ConversationList dummyMainMethod_com_csipsimple_ui_messages_ConversationList(android.content.Intent)>
	2: <com.csipsimple.ui.messages.ConversationList$2: void onClick(android.content.DialogInterface,int)>
	3: <com.csipsimple.ui.messages.ConversationList: void access$000(com.csipsimple.ui.messages.ConversationList)>
	4: <com.csipsimple.ui.messages.ConversationList: void updateAdapter()>
	5: <com.csipsimple.db.DBAdapter: android.database.Cursor getAllConversations()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.CallLog dummyMainMethod_com_csipsimple_ui_CallLog(android.content.Intent)>
	2: <com.csipsimple.ui.CallLog: void onResume()>
	3: <com.csipsimple.ui.CallLog: void updateData(int)>
	4: <com.csipsimple.db.DBAdapter: android.database.Cursor getCallLog(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.ReorderAccountsList dummyMainMethod_com_csipsimple_ui_ReorderAccountsList(android.content.Intent)>
	2: <com.csipsimple.ui.ReorderAccountsList: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.ui.ReorderAccountsList: void initDatas()>
	4: <com.csipsimple.db.DBAdapter: java.util.List getListAccounts()>
	5: <com.csipsimple.db.DBAdapter: java.util.List getListAccounts(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.AccountFilters dummyMainMethod_com_csipsimple_ui_AccountFilters(android.content.Intent)>
	2: <com.csipsimple.ui.AccountFilters: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.db.DBAdapter: com.csipsimple.api.SipProfile getAccount(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.messages.ComposeMessageActivity dummyMainMethod_com_csipsimple_ui_messages_ComposeMessageActivity(android.content.Intent)>
	2: <com.csipsimple.ui.messages.ComposeMessageActivity: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.ui.messages.ComposeMessageActivity: void loadMessageContent()>
	4: <com.csipsimple.db.DBAdapter: android.database.Cursor getConversation(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.AccountFilters dummyMainMethod_com_csipsimple_ui_AccountFilters(android.content.Intent)>
	2: <com.csipsimple.ui.AccountFilters: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.db.DBAdapter: android.database.Cursor getFiltersForAccount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.SipHome dummyMainMethod_com_csipsimple_ui_SipHome(android.content.Intent)>
	2: <com.csipsimple.ui.SipHome: void onResume()>
	3: <com.csipsimple.ui.SipHome: void startSipService()>
	4: <com.csipsimple.ui.SipHome$1: void run()>
	5: <com.csipsimple.ui.SipHome: void access$100(com.csipsimple.ui.SipHome)>
	6: <com.csipsimple.ui.SipHome: void postStartSipService()>
	7: <com.csipsimple.db.DBAdapter: int getNbrOfAccount()>
	8: <com.csipsimple.db.DBAdapter: int getNbrOfAccount(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.EditFilter dummyMainMethod_com_csipsimple_ui_EditFilter(android.content.Intent)>
	2: <com.csipsimple.ui.EditFilter$2: void onClick(android.view.View)>
	3: <com.csipsimple.ui.EditFilter: void access$000(com.csipsimple.ui.EditFilter)>
	4: <com.csipsimple.ui.EditFilter: void saveFilter()>
	5: <com.csipsimple.db.DBAdapter: int getCountFiltersForAccount(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.service.SipService$ServiceDeviceStateReceiver dummyMainMethod_com_csipsimple_service_SipService$ServiceDeviceStateReceiver(android.content.Intent)>
	2: <com.csipsimple.service.SipService$ServiceDeviceStateReceiver: void onReceive(android.content.Context,android.content.Intent)>
	3: <com.csipsimple.service.SipService$SipServiceExecutor: void execute(java.lang.Runnable)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.SipHome dummyMainMethod_com_csipsimple_ui_SipHome(android.content.Intent)>
	2: <com.csipsimple.ui.SipHome: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <com.csipsimple.db.DBAdapter: com.csipsimple.api.SipProfile getAccountForWizard(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.widgets.AccountWidgetProvider dummyMainMethod_com_csipsimple_widgets_AccountWidgetProvider(android.content.Intent)>
	2: <com.csipsimple.widgets.AccountWidgetProvider: void onUpdate(android.content.Context,android.appwidget.AppWidgetManager,int[])>
	3: <com.csipsimple.widgets.AccountWidgetProvider: android.widget.RemoteViews buildUpdate(android.content.Context,int)>
	4: <com.csipsimple.db.DBAdapter: android.content.ContentValues getAccountValues(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.EditFilter dummyMainMethod_com_csipsimple_ui_EditFilter(android.content.Intent)>
	2: <com.csipsimple.ui.EditFilter: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.db.DBAdapter: com.csipsimple.models.Filter getFilter(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.csipsimple.ui.CallLogsList dummyMainMethod_com_csipsimple_ui_CallLogsList(android.content.Intent)>
	2: <com.csipsimple.ui.CallLogsList: void onCreate(android.os.Bundle)>
	3: <com.csipsimple.db.DBAdapter: android.database.Cursor getAllCallLogs()>

Resource: android.view.MotionEvent
source method: stopMovement()
source file: ContactListFragment.java
Our analysis output:
Soot started on Sun May 03 02:59:15 EDT 2020
Soot finished on Sun May 03 02:59:42 EDT 2020
Soot has run for 0 min. 26 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-fc102fb69f.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-121cd5803b.apk
File does not exist: ./DroidLeaks/apps/APG-rev-727783dd00.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-406aae6e61.apk
File does not exist: ./DroidLeaks/apps/AnkiDroid-rev-8315e1fa10.apk
File does not exist: ./DroidLeaks/apps/Osmand-rev-053abea161.apk
File does not exist: ./DroidLeaks/apps/Osmand-rev-2aa87f74cc.apk
File does not exist: ./DroidLeaks/apps/CallMeter-rev-b0c2afad23.apk
File does not exist: ./DroidLeaks/apps/Owncloud-rev-74c29e1ce1.apk
Resource: java.io.BufferedReader
source method: inputStreamToString() @line 40
source file: Utils.java
Our analysis output:
Soot started on Sun May 03 03:00:03 EDT 2020
Soot finished on Sun May 03 03:00:38 EDT 2020
Soot has run for 0 min. 34 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

File does not exist: ./DroidLeaks/apps/VLC-rev-f106951756.apk
File does not exist: ./DroidLeaks/apps/CSipSimple-rev-a94f7336d0.apk
Resource: java.io.BufferedWriter
source method: writeLog()
source file: VLCCrashHandler.java
Our analysis output:
Soot started on Sun May 03 03:01:04 EDT 2020
Soot finished on Sun May 03 03:01:23 EDT 2020
Soot has run for 0 min. 18 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity: boolean onTouchEvent(android.view.MotionEvent)>
	3: <org.videolan.vlc.gui.video.VideoPlayerActivity: void doSeekTouch(float,float,boolean)>
	4: <org.videolan.vlc.gui.video.VideoPlayerActivity: void showInfo(int,int)>
	5: <org.videolan.vlc.gui.video.VideoGridFragment$VideoListHandler: void handleMessage(android.os.Message)>
	6: <org.videolan.vlc.gui.video.VideoGridFragment: void access$600(org.videolan.vlc.gui.video.VideoGridFragment)>
	7: <org.videolan.vlc.gui.video.VideoGridFragment: void updateList()>
	8: <org.videolan.vlc.Thumbnailer: void addJob(org.videolan.libvlc.Media)>
	9: <org.videolan.vlc.util.BitmapUtil: android.graphics.Bitmap getPictureFromCache(org.videolan.libvlc.Media)>
	10: <org.videolan.vlc.MediaDatabase: android.graphics.Bitmap getPicture(android.content.Context,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.BrowserActivity dummyMainMethod_org_videolan_vlc_gui_BrowserActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.BrowserActivity$1: boolean onMenuItemClick(android.view.MenuItem)>
	3: <org.videolan.vlc.MediaDatabase: java.util.List getMediaDirs()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity$10: void onClick(android.content.DialogInterface,int)>
	3: <org.videolan.vlc.gui.video.VideoPlayerActivity: void access$3300(org.videolan.vlc.gui.video.VideoPlayerActivity)>
	4: <org.videolan.vlc.gui.video.VideoPlayerActivity: void loadMedia()>
	5: <org.videolan.vlc.MediaDatabase: org.videolan.libvlc.Media getMedia(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.media.AudioManager: int requestAudioFocus(android.media.AudioManager$OnAudioFocusChangeListener,int,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity: boolean onTouchEvent(android.view.MotionEvent)>
	3: <org.videolan.vlc.gui.video.VideoPlayerActivity: void doSeekTouch(float,float,boolean)>
	4: <org.videolan.vlc.gui.video.VideoPlayerActivity: void showInfo(int,int)>
	5: <org.videolan.vlc.gui.video.VideoPlayerActivity$VideoPlayerEventHandler: void handleMessage(android.os.Message)>
	6: <org.videolan.vlc.gui.video.VideoPlayerActivity: int access$2000(org.videolan.vlc.gui.video.VideoPlayerActivity,boolean)>
	7: <org.videolan.vlc.gui.video.VideoPlayerActivity: int changeAudioFocus(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.MainActivity dummyMainMethod_org_videolan_vlc_gui_MainActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.MainActivity: void onCreate(android.os.Bundle)>
	3: <android.os.Handler: boolean postDelayed(java.lang.Runnable,long)>
	4: <org.videolan.vlc.MediaLibrary$GetMediaItemsRunnable: void run()>
	5: <org.videolan.vlc.MediaDatabase: java.util.HashMap getMedias()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity: void onPause()>
	3: <org.videolan.vlc.MediaDatabase: boolean mediaItemExists(java.lang.String)>

Resource: java.io.BufferedWriter
source method: writeLogcat()
source file: Logcat.java
Our analysis output:
Soot started on Sun May 03 03:01:31 EDT 2020
Soot finished on Sun May 03 03:01:50 EDT 2020
Soot has run for 0 min. 18 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity: boolean onTouchEvent(android.view.MotionEvent)>
	3: <org.videolan.vlc.gui.video.VideoPlayerActivity: void doSeekTouch(float,float,boolean)>
	4: <org.videolan.vlc.gui.video.VideoPlayerActivity: void showInfo(int,int)>
	5: <org.videolan.vlc.gui.video.VideoGridFragment$VideoListHandler: void handleMessage(android.os.Message)>
	6: <org.videolan.vlc.gui.video.VideoGridFragment: void access$600(org.videolan.vlc.gui.video.VideoGridFragment)>
	7: <org.videolan.vlc.gui.video.VideoGridFragment: void updateList()>
	8: <org.videolan.vlc.Thumbnailer: void addJob(org.videolan.libvlc.Media)>
	9: <org.videolan.vlc.util.BitmapUtil: android.graphics.Bitmap getPictureFromCache(org.videolan.libvlc.Media)>
	10: <org.videolan.vlc.MediaDatabase: android.graphics.Bitmap getPicture(android.content.Context,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.MainActivity dummyMainMethod_org_videolan_vlc_gui_MainActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.MainActivity: void onCreate(android.os.Bundle)>
	3: <android.os.Handler: boolean postDelayed(java.lang.Runnable,long)>
	4: <org.videolan.vlc.MediaLibrary$GetMediaItemsRunnable: void run()>
	5: <org.videolan.vlc.MediaDatabase: java.util.HashMap getMedias()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.BrowserActivity dummyMainMethod_org_videolan_vlc_gui_BrowserActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.BrowserActivity$1: boolean onMenuItemClick(android.view.MenuItem)>
	3: <org.videolan.vlc.MediaDatabase: java.util.List getMediaDirs()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity$10: void onClick(android.content.DialogInterface,int)>
	3: <org.videolan.vlc.gui.video.VideoPlayerActivity: void access$3300(org.videolan.vlc.gui.video.VideoPlayerActivity)>
	4: <org.videolan.vlc.gui.video.VideoPlayerActivity: void loadMedia()>
	5: <org.videolan.vlc.MediaDatabase: org.videolan.libvlc.Media getMedia(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.media.AudioManager: int requestAudioFocus(android.media.AudioManager$OnAudioFocusChangeListener,int,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity: boolean onTouchEvent(android.view.MotionEvent)>
	3: <org.videolan.vlc.gui.video.VideoPlayerActivity: void doSeekTouch(float,float,boolean)>
	4: <org.videolan.vlc.gui.video.VideoPlayerActivity: void showInfo(int,int)>
	5: <org.videolan.vlc.gui.video.VideoPlayerActivity$VideoPlayerEventHandler: void handleMessage(android.os.Message)>
	6: <org.videolan.vlc.gui.video.VideoPlayerActivity: int access$2000(org.videolan.vlc.gui.video.VideoPlayerActivity,boolean)>
	7: <org.videolan.vlc.gui.video.VideoPlayerActivity: int changeAudioFocus(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity: void onPause()>
	3: <org.videolan.vlc.MediaDatabase: boolean mediaItemExists(java.lang.String)>

Resource: java.io.ByteArrayOutputStream
source method: inputStreamToBytes() @line 56
source file: Utils.java
Our analysis output:
Soot started on Sun May 03 03:01:59 EDT 2020
Soot finished on Sun May 03 03:02:32 EDT 2020
Soot has run for 0 min. 33 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: java.io.ByteArrayOutputStream
source method: inputStreamToBase64() @line 68
source file: Utils.java
Our analysis output:
Soot started on Sun May 03 03:02:59 EDT 2020
Soot finished on Sun May 03 03:03:33 EDT 2020
Soot has run for 0 min. 33 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: java.io.DataOutputStream
source method: writeCache() @line 69
source file: ParcelableFileCache.java
Our analysis output:
Soot started on Sun May 03 03:04:00 EDT 2020
Soot finished on Sun May 03 03:05:02 EDT 2020
Soot has run for 1 min. 2 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.sufficientlysecure.keychain.util.ParcelableFileCache$1: void readNext()>
SINK:
	<org.sufficientlysecure.keychain.util.ParcelableFileCache$1: void readNext()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.sufficientlysecure.keychain.util.ParcelableFileCache: void writeCache(int,java.util.Iterator)>
SINK:
	<org.sufficientlysecure.keychain.util.ParcelableFileCache: void writeCache(int,java.util.Iterator)>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.remote.CryptoInputParcelCacheService dummyMainMethod_org_sufficientlysecure_keychain_remote_CryptoInputParcelCacheService(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.remote.CryptoInputParcelCacheService: int onStartCommand(android.content.Intent,int,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.service.PassphraseCacheService dummyMainMethod_org_sufficientlysecure_keychain_service_PassphraseCacheService(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.service.PassphraseCacheService: int onStartCommand(android.content.Intent,int,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.service.KeychainService dummyMainMethod_org_sufficientlysecure_keychain_service_KeychainService(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.service.KeychainService: int onStartCommand(android.content.Intent,int,int)>
	3: <java.lang.Thread: void run()>
	4: <org.sufficientlysecure.keychain.service.KeychainService$1: void run()>
	5: <org.sufficientlysecure.keychain.service.KeychainService: void serialKeyImport(java.util.ArrayList,java.lang.String,org.sufficientlysecure.keychain.provider.ProviderHelper)>
	6: <org.sufficientlysecure.keychain.service.KeychainService: void sendMessageToHandler(org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,org.sufficientlysecure.keychain.operations.results.OperationResult)>
	7: <org.sufficientlysecure.keychain.service.KeychainService: void sendMessageToHandler(org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,java.lang.Integer,android.os.Bundle)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.ui.ViewKeyActivity dummyMainMethod_org_sufficientlysecure_keychain_ui_ViewKeyActivity(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.ui.ViewKeyActivity: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <org.sufficientlysecure.keychain.service.PassphraseCacheService: org.sufficientlysecure.keychain.util.Passphrase getCachedPassphrase(android.content.Context,long,long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.provider.KeychainProvider dummyMainMethod_org_sufficientlysecure_keychain_provider_KeychainProvider(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.provider.KeychainProvider: android.net.Uri insert(android.net.Uri,android.content.ContentValues)>
	3: <org.sufficientlysecure.keychain.provider.KeychainProvider: org.sufficientlysecure.keychain.provider.KeychainDatabase getDb()>
	4: <org.sufficientlysecure.keychain.provider.KeychainDatabase: void <init>(android.content.Context)>
	5: <org.sufficientlysecure.keychain.provider.KeychainDatabase: void checkAndImportApg(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.service.KeychainService dummyMainMethod_org_sufficientlysecure_keychain_service_KeychainService(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.service.KeychainService: int onStartCommand(android.content.Intent,int,int)>
	3: <java.lang.Thread: void run()>
	4: <org.sufficientlysecure.keychain.service.KeychainNewService$1: void run()>
	5: <org.sufficientlysecure.keychain.service.KeychainNewService: void access$100(org.sufficientlysecure.keychain.service.KeychainNewService,org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,org.sufficientlysecure.keychain.operations.results.OperationResult)>
	6: <org.sufficientlysecure.keychain.service.KeychainNewService: void sendMessageToHandler(org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,org.sufficientlysecure.keychain.operations.results.OperationResult)>
	7: <org.sufficientlysecure.keychain.service.KeychainNewService: void sendMessageToHandler(org.sufficientlysecure.keychain.service.ServiceProgressHandler$MessageStatus,java.lang.Integer,android.os.Bundle)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.provider.KeychainProvider dummyMainMethod_org_sufficientlysecure_keychain_provider_KeychainProvider(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.provider.KeychainProvider: android.net.Uri insert(android.net.Uri,android.content.ContentValues)>
	3: <org.sufficientlysecure.keychain.provider.KeychainProvider: org.sufficientlysecure.keychain.provider.KeychainDatabase getDb()>
	4: <org.sufficientlysecure.keychain.provider.KeychainDatabase: void <init>(android.content.Context)>
	5: <org.sufficientlysecure.keychain.provider.KeychainDatabase: void checkAndImportApg(android.content.Context)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.provider.TemporaryStorageProvider dummyMainMethod_org_sufficientlysecure_keychain_provider_TemporaryStorageProvider(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.provider.TemporaryStorageProvider: int delete(android.net.Uri,java.lang.String,java.lang.String[])>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.sufficientlysecure.keychain.provider.TemporaryStorageProvider dummyMainMethod_org_sufficientlysecure_keychain_provider_TemporaryStorageProvider(android.content.Intent)>
	2: <org.sufficientlysecure.keychain.provider.TemporaryStorageProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>

File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-3253466f14.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-39aa577651.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-e3f6561008.apk
File does not exist: ./DroidLeaks/apps/Osmand-rev-28f3b74069.apk
File does not exist: ./DroidLeaks/apps/Osmand-rev-28f3b74069.apk
File does not exist: ./DroidLeaks/apps/Osmand-rev-50249440e2.apk
File does not exist: ./DroidLeaks/apps/Cgeo-rev-baf51975fa.apk
File does not exist: ./DroidLeaks/apps/VLC-rev-f106951756.apk
File does not exist: ./DroidLeaks/apps/Wordpress-rev-5eaf6cc07f.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-f2ae50bcba.apk
Resource: java.io.FileInputStream
source method: fetch() @line 79
source file: ApiCallCache.java
Our analysis output:
Soot started on Sun May 03 03:05:39 EDT 2020
Soot finished on Sun May 03 03:05:56 EDT 2020
Soot has run for 0 min. 17 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.cyclestreets.RouteMapActivity dummyMainMethod_net_cyclestreets_RouteMapActivity(android.content.Intent)>
	2: <net.cyclestreets.RouteMapActivity: boolean onPrepareOptionsMenu(android.view.Menu)>
	3: <net.cyclestreets.planned.Route: int storedCount()>
	4: <net.cyclestreets.content.RouteDatabase: int routeCount()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.cyclestreets.StoredRoutesActivity dummyMainMethod_net_cyclestreets_StoredRoutesActivity(android.content.Intent)>
	2: <net.cyclestreets.StoredRoutesActivity: void onCreate(android.os.Bundle)>
	3: <net.cyclestreets.planned.Route: java.util.List storedRoutes()>
	4: <net.cyclestreets.content.RouteDatabase: java.util.List savedRoutes()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.cyclestreets.RouteMapActivity dummyMainMethod_net_cyclestreets_RouteMapActivity(android.content.Intent)>
	2: <net.cyclestreets.RouteMapActivity: void onActivityResult(int,int,android.content.Intent)>
	3: <net.cyclestreets.RouteMapActivity: void onStoredRouteNow(int)>
	4: <net.cyclestreets.planned.Route: void PlotStoredRoute(int,net.cyclestreets.planned.Route$Callback,android.content.Context)>
	5: <net.cyclestreets.planned.StoredRoutingTask: java.lang.Object doInBackground(java.lang.Object[])>
	6: <net.cyclestreets.planned.StoredRoutingTask: net.cyclestreets.content.RouteData doInBackground(java.lang.Integer[])>
	7: <net.cyclestreets.content.RouteDatabase: net.cyclestreets.content.RouteData route(int)>
	8: <net.cyclestreets.content.RouteDatabase: net.cyclestreets.content.RouteData fetchRoute(java.lang.String,java.lang.String[])>

File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-39aa577651.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-057b316bcb.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-e3f6561008.apk
File does not exist: ./DroidLeaks/apps/FBReaderJ-rev-c3d00e2dd.apk
File does not exist: ./DroidLeaks/apps/Osmand-rev-266e62c459.apk
File does not exist: ./DroidLeaks/apps/Cgeo-rev-baf51975fa.apk
File does not exist: ./DroidLeaks/apps/Xabber-rev-872233a339.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-121cd5803b.apk
File does not exist: ./DroidLeaks/apps/OsmDroid-rev-30135da42f.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-ba1ae18409.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-ba1ae18409.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-ba1ae18409.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-ba1ae18409.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-ba1ae18409.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-12d1097a24.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-057b316bcb.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-ba1ae18409.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-ba1ae18409.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-ba1ae18409.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-ba1ae18409.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-ba1ae18409.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-ba1ae18409.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-ba1ae18409.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-acd18291f2.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-fcabb7395d.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-1596ddfaab.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-3253466f14.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-602ce7be99.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-378acbd313.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-6cd52c123c.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-12d1097a24.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-057b316bcb.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-406aae6e61.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-dfa97cd878.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-dfa97cd878.apk
File does not exist: ./DroidLeaks/apps/FBReaderJ-rev-0466e8d1a6.apk
File does not exist: ./DroidLeaks/apps/FBReaderJ-rev-536aa6fafa.apk
File does not exist: ./DroidLeaks/apps/Osmand-rev-2da1458999.apk
File does not exist: ./DroidLeaks/apps/Osmand-rev-9d967a96ae.apk
File does not exist: ./DroidLeaks/apps/Osmand-rev-2aa87f74cc.apk
File does not exist: ./DroidLeaks/apps/Osmand-rev-681f6a27e0.apk
File does not exist: ./DroidLeaks/apps/CallMeter-rev-b0c2afad23.apk
File does not exist: ./DroidLeaks/apps/Cgeo-rev-1f1b81c531.apk
File does not exist: ./DroidLeaks/apps/Cgeo-rev-c05dbd6fdf.apk
File does not exist: ./DroidLeaks/apps/Owncloud-rev-10e4373bcf.apk
Resource: java.io.InputStream
source method: run() @line 147
source file: EncryptionController.java
Our analysis output:
Soot started on Sun May 03 03:06:09 EDT 2020
Soot finished on Sun May 03 03:06:45 EDT 2020
Soot has run for 0 min. 36 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.twofours.surespot.activities.ImageSelectActivity: android.hardware.Camera getCameraInstance()>
SINK:
	<com.twofours.surespot.activities.ImageSelectActivity: void releaseCamera()>
==========================(Resources)==============================

Resource: java.io.InputStream
source method: run() @line 204
source file: EncryptionController.java
Our analysis output:
Soot started on Sun May 03 03:07:22 EDT 2020
Soot finished on Sun May 03 03:07:59 EDT 2020
Soot has run for 0 min. 37 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.hardware.Camera: android.hardware.Camera open()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.twofours.surespot.activities.ImageSelectActivity dummyMainMethod_com_twofours_surespot_activities_ImageSelectActivity(android.content.Intent)>
	2: <com.twofours.surespot.activities.ImageSelectActivity: void onCreate(android.os.Bundle)>
	3: <com.twofours.surespot.activities.ImageSelectActivity: android.hardware.Camera getCameraInstance()>

Resource: java.io.InputStream
source method: inputStreamToString() @line 40
source file: Utils.java
Our analysis output:
Soot started on Sun May 03 03:08:34 EDT 2020
Soot finished on Sun May 03 03:09:08 EDT 2020
Soot has run for 0 min. 33 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: java.io.InputStream
source method: inputStreamToBytes() @line 56
source file: Utils.java
Our analysis output:
Soot started on Sun May 03 03:09:35 EDT 2020
Soot finished on Sun May 03 03:10:09 EDT 2020
Soot has run for 0 min. 34 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: java.io.InputStream
source method: inputStreamToBase64() @line 68
source file: Utils.java
Our analysis output:
Soot started on Sun May 03 03:10:35 EDT 2020
Soot finished on Sun May 03 03:11:11 EDT 2020
Soot has run for 0 min. 36 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

File does not exist: ./DroidLeaks/apps/Bankdroid-rev-096d565e3d.apk
File does not exist: ./DroidLeaks/apps/Quran for Android-rev-a632e803c5.apk
File does not exist: ./DroidLeaks/apps/Terminal-rev-7ede276096.apk
File does not exist: ./DroidLeaks/apps/ChatSecure-rev-f2ae50bcba.apk
File does not exist: ./DroidLeaks/apps/Zxing-rev-35e13989af.apk
File does not exist: ./DroidLeaks/apps/FBReaderJ-rev-59187733c9.apk
File does not exist: ./DroidLeaks/apps/Hacker News-rev-3491bef7d1.apk
File does not exist: ./DroidLeaks/apps/Hacker News-rev-3491bef7d1.apk
File does not exist: ./DroidLeaks/apps/Hacker News-rev-3491bef7d1.apk
File does not exist: ./DroidLeaks/apps/Hacker News-rev-3491bef7d1.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-acd18291f2.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-20eab9c812.apk
Resource: java.io.OutputStream
source method: run() @line 147
source file: EncryptionController.java
Our analysis output:
Soot started on Sun May 03 03:11:37 EDT 2020
Soot finished on Sun May 03 03:12:16 EDT 2020
Soot has run for 0 min. 38 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.twofours.surespot.activities.ImageSelectActivity: android.hardware.Camera getCameraInstance()>
SINK:
	<com.twofours.surespot.activities.ImageSelectActivity: void releaseCamera()>
==========================(Resources)==============================

Resource: java.io.OutputStream
source method: run() @line 204
source file: EncryptionController.java
Our analysis output:
Soot started on Sun May 03 03:12:52 EDT 2020
Soot finished on Sun May 03 03:13:30 EDT 2020
Soot has run for 0 min. 37 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<com.twofours.surespot.activities.ImageSelectActivity: android.hardware.Camera getCameraInstance()>
SINK:
	<com.twofours.surespot.activities.ImageSelectActivity: void releaseCamera()>
==========================(Resources)==============================

File does not exist: ./DroidLeaks/apps/Terminal-rev-7ede276096.apk
Resource: java.io.OutputStreamWriter
source method: writeLog()
source file: VLCCrashHandler.java
Our analysis output:
Soot started on Sun May 03 03:14:06 EDT 2020
Soot finished on Sun May 03 03:14:24 EDT 2020
Soot has run for 0 min. 18 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity: boolean onTouchEvent(android.view.MotionEvent)>
	3: <org.videolan.vlc.gui.video.VideoPlayerActivity: void doSeekTouch(float,float,boolean)>
	4: <org.videolan.vlc.gui.video.VideoPlayerActivity: void showInfo(int,int)>
	5: <org.videolan.vlc.gui.video.VideoGridFragment$VideoListHandler: void handleMessage(android.os.Message)>
	6: <org.videolan.vlc.gui.video.VideoGridFragment: void access$600(org.videolan.vlc.gui.video.VideoGridFragment)>
	7: <org.videolan.vlc.gui.video.VideoGridFragment: void updateList()>
	8: <org.videolan.vlc.Thumbnailer: void addJob(org.videolan.libvlc.Media)>
	9: <org.videolan.vlc.util.BitmapUtil: android.graphics.Bitmap getPictureFromCache(org.videolan.libvlc.Media)>
	10: <org.videolan.vlc.MediaDatabase: android.graphics.Bitmap getPicture(android.content.Context,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.BrowserActivity dummyMainMethod_org_videolan_vlc_gui_BrowserActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.BrowserActivity$1: boolean onMenuItemClick(android.view.MenuItem)>
	3: <org.videolan.vlc.MediaDatabase: java.util.List getMediaDirs()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity$10: void onClick(android.content.DialogInterface,int)>
	3: <org.videolan.vlc.gui.video.VideoPlayerActivity: void access$3300(org.videolan.vlc.gui.video.VideoPlayerActivity)>
	4: <org.videolan.vlc.gui.video.VideoPlayerActivity: void loadMedia()>
	5: <org.videolan.vlc.MediaDatabase: org.videolan.libvlc.Media getMedia(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.media.AudioManager: int requestAudioFocus(android.media.AudioManager$OnAudioFocusChangeListener,int,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity: boolean onTouchEvent(android.view.MotionEvent)>
	3: <org.videolan.vlc.gui.video.VideoPlayerActivity: void doSeekTouch(float,float,boolean)>
	4: <org.videolan.vlc.gui.video.VideoPlayerActivity: void showInfo(int,int)>
	5: <org.videolan.vlc.gui.video.VideoPlayerActivity$VideoPlayerEventHandler: void handleMessage(android.os.Message)>
	6: <org.videolan.vlc.gui.video.VideoPlayerActivity: int access$2000(org.videolan.vlc.gui.video.VideoPlayerActivity,boolean)>
	7: <org.videolan.vlc.gui.video.VideoPlayerActivity: int changeAudioFocus(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.MainActivity dummyMainMethod_org_videolan_vlc_gui_MainActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.MainActivity: void onCreate(android.os.Bundle)>
	3: <android.os.Handler: boolean postDelayed(java.lang.Runnable,long)>
	4: <org.videolan.vlc.MediaLibrary$GetMediaItemsRunnable: void run()>
	5: <org.videolan.vlc.MediaDatabase: java.util.HashMap getMedias()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity: void onPause()>
	3: <org.videolan.vlc.MediaDatabase: boolean mediaItemExists(java.lang.String)>

Resource: java.io.OutputStreamWriter
source method: writeLogcat()
source file: Logcat.java
Our analysis output:
Soot started on Sun May 03 03:14:34 EDT 2020
Soot finished on Sun May 03 03:14:53 EDT 2020
Soot has run for 0 min. 19 sec.
Starting analysis...
Analysis finished.
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void updateProgress()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase: void removeMedias(java.util.Set)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void removeAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
SINK:
	<org.videolan.vlc.MediaDatabase$DatabaseHelper: android.database.sqlite.SQLiteDatabase getWritableDatabase()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
SINK:
	<org.videolan.vlc.interfaces.IAudioServiceCallback$Stub$Proxy: void update()>
DATAFLOW PATH FOUND:
Variable: null
SOURCE:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
SINK:
	<org.videolan.vlc.interfaces.IAudioService$Stub$Proxy: void addAudioCallback(org.videolan.vlc.interfaces.IAudioServiceCallback)>
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity: boolean onTouchEvent(android.view.MotionEvent)>
	3: <org.videolan.vlc.gui.video.VideoPlayerActivity: void doSeekTouch(float,float,boolean)>
	4: <org.videolan.vlc.gui.video.VideoPlayerActivity: void showInfo(int,int)>
	5: <org.videolan.vlc.gui.video.VideoGridFragment$VideoListHandler: void handleMessage(android.os.Message)>
	6: <org.videolan.vlc.gui.video.VideoGridFragment: void access$600(org.videolan.vlc.gui.video.VideoGridFragment)>
	7: <org.videolan.vlc.gui.video.VideoGridFragment: void updateList()>
	8: <org.videolan.vlc.Thumbnailer: void addJob(org.videolan.libvlc.Media)>
	9: <org.videolan.vlc.util.BitmapUtil: android.graphics.Bitmap getPictureFromCache(org.videolan.libvlc.Media)>
	10: <org.videolan.vlc.MediaDatabase: android.graphics.Bitmap getPicture(android.content.Context,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.MainActivity dummyMainMethod_org_videolan_vlc_gui_MainActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.MainActivity: void onCreate(android.os.Bundle)>
	3: <android.os.Handler: boolean postDelayed(java.lang.Runnable,long)>
	4: <org.videolan.vlc.MediaLibrary$GetMediaItemsRunnable: void run()>
	5: <org.videolan.vlc.MediaDatabase: java.util.HashMap getMedias()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.BrowserActivity dummyMainMethod_org_videolan_vlc_gui_BrowserActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.BrowserActivity$1: boolean onMenuItemClick(android.view.MenuItem)>
	3: <org.videolan.vlc.MediaDatabase: java.util.List getMediaDirs()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity$10: void onClick(android.content.DialogInterface,int)>
	3: <org.videolan.vlc.gui.video.VideoPlayerActivity: void access$3300(org.videolan.vlc.gui.video.VideoPlayerActivity)>
	4: <org.videolan.vlc.gui.video.VideoPlayerActivity: void loadMedia()>
	5: <org.videolan.vlc.MediaDatabase: org.videolan.libvlc.Media getMedia(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.media.AudioManager: int requestAudioFocus(android.media.AudioManager$OnAudioFocusChangeListener,int,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity: boolean onTouchEvent(android.view.MotionEvent)>
	3: <org.videolan.vlc.gui.video.VideoPlayerActivity: void doSeekTouch(float,float,boolean)>
	4: <org.videolan.vlc.gui.video.VideoPlayerActivity: void showInfo(int,int)>
	5: <org.videolan.vlc.gui.video.VideoPlayerActivity$VideoPlayerEventHandler: void handleMessage(android.os.Message)>
	6: <org.videolan.vlc.gui.video.VideoPlayerActivity: int access$2000(org.videolan.vlc.gui.video.VideoPlayerActivity,boolean)>
	7: <org.videolan.vlc.gui.video.VideoPlayerActivity: int changeAudioFocus(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: org.videolan.vlc.gui.video.VideoPlayerActivity dummyMainMethod_org_videolan_vlc_gui_video_VideoPlayerActivity(android.content.Intent)>
	2: <org.videolan.vlc.gui.video.VideoPlayerActivity: void onPause()>
	3: <org.videolan.vlc.MediaDatabase: boolean mediaItemExists(java.lang.String)>

File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-0a07250417.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-0a07250417.apk
File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-acd18291f2.apk
Resource: java.net.Socket
source method: run()
source file: GingerbreadImageProxy.java
Our analysis output:
Soot started on Sun May 03 03:15:02 EDT 2020
Soot finished on Sun May 03 03:15:44 EDT 2020
Soot has run for 0 min. 41 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

File does not exist: ./DroidLeaks/apps/K-9 Mail-rev-3171ee969f.apk
Resource: java.util.concurrent.Semaphore
source method: onChainDownloadStarted()
source file: DownloadListener.java
Our analysis output:
Soot started on Sun May 03 03:16:28 EDT 2020
Soot finished on Sun May 03 03:16:51 EDT 2020
Soot has run for 0 min. 22 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: java.util.concurrent.Semaphore
source method: onReceive()
source file: OpenGeoSMSSender.java
Our analysis output:
Exception in thread "main" java.lang.RuntimeException: Manifest contains no application node
	at soot.jimple.infoflow.android.manifest.ProcessManifest.handle(ProcessManifest.java:138)
	at soot.jimple.infoflow.android.manifest.ProcessManifest.<init>(ProcessManifest.java:98)
	at soot.jimple.infoflow.android.SetupApplication.parseAppResources(SetupApplication.java:420)
	at soot.jimple.infoflow.android.SetupApplication.runInfoflow(SetupApplication.java:1391)
	at soot.jimple.infoflow.android.SetupApplication.constructCallgraph(SetupApplication.java:1258)
	at com.guitard0g.dataflow_analysis.App.main(App.java:53)
Soot started on Sun May 03 03:17:04 EDT 2020
Soot finished on Sun May 03 03:17:22 EDT 2020
Soot has run for 0 min. 18 sec.

Resource: java.util.Formatter
source method: appendReport() @line 291
source file: ErrorReporter.java
Our analysis output:
Soot started on Sun May 03 03:17:25 EDT 2020
Soot finished on Sun May 03 03:18:12 EDT 2020
Soot has run for 0 min. 46 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================

Resource: java.util.logging.FileHandler
source method: generateIndex() @line 497
source file: IndexBatchCreator.java
Our analysis output:
Soot started on Sun May 03 03:18:40 EDT 2020
Soot finished on Sun May 03 03:20:27 EDT 2020
Soot has run for 1 min. 46 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivityLayers$7: void onClick(android.content.DialogInterface,int)>
	3: <net.osmand.plus.views.MapControlsLayer: void showAndHideTransparencyBar(net.osmand.plus.OsmandSettings$CommonPreference,net.osmand.plus.views.BaseMapLayer[])>
	4: <net.osmand.plus.views.MapControlsLayer: void showAndHideTransparencyBar(net.osmand.plus.OsmandSettings$CommonPreference,net.osmand.plus.views.BaseMapLayer[],int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.activities.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.ResourceManager: void <init>(net.osmand.plus.activities.OsmandApplication)>
	3: <net.osmand.plus.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.routing.RouteAnimation$1$1: void run()>
	5: <net.osmand.plus.activities.MapActivity: void setLocation(android.location.Location)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivityActions$2: void onClick(android.content.DialogInterface,int)>
	3: <net.osmand.plus.FavouritesDbHelper: boolean addFavourite(net.osmand.FavouritePoint)>
	4: <net.osmand.plus.FavouritesDbHelper: void checkFavoritePoints()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.activities.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.ResourceManager: void <init>(net.osmand.plus.activities.OsmandApplication)>
	3: <net.osmand.plus.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.ResourceManager: android.graphics.Bitmap getRequestedImageTile(net.osmand.plus.AsyncLoadingThread$TileLoadDownloadRequest)>
	5: <net.osmand.plus.SQLiteTileSource: android.graphics.Bitmap getImage(int,int,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.activities.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.ResourceManager: void <init>(net.osmand.plus.activities.OsmandApplication)>
	3: <net.osmand.plus.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.activities.SettingsActivity$7: void run()>
	5: <net.osmand.plus.activities.SavingTrackHelper: java.util.List saveDataToGpx()>
	6: <net.osmand.plus.activities.SavingTrackHelper: void collectDBPoints(android.database.sqlite.SQLiteDatabase,java.util.Map)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.sqlite.SQLiteDatabase openOrCreateDatabase(java.io.File,android.database.sqlite.SQLiteDatabase$CursorFactory)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivityActions$6: void onClick(android.content.DialogInterface,int)>
	3: <net.osmand.plus.activities.MapActivityActions: void updatePoiDb(int,double,double)>
	4: <net.osmand.plus.ResourceManager: net.osmand.plus.AmenityIndexRepositoryOdb getUpdatablePoiDb()>
	5: <net.osmand.plus.ResourceManager: boolean tryToOpenUpdatablePoiDb(java.io.File)>
	6: <net.osmand.plus.AmenityIndexRepositoryOdb: boolean initialize(net.osmand.IProgress,java.io.File)>
	7: <net.osmand.plus.BaseLocationIndexRepository: boolean initialize(net.osmand.IProgress,java.io.File,int,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.activities.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.ResourceManager: void <init>(net.osmand.plus.activities.OsmandApplication)>
	3: <net.osmand.plus.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.views.OsmandMapTileView$1: void run()>
	5: <net.osmand.plus.views.OsmandMapTileView: void access$300(net.osmand.plus.views.OsmandMapTileView,boolean)>
	6: <net.osmand.plus.views.OsmandMapTileView: void refreshMapInternal(boolean)>
	7: <net.osmand.plus.views.OsmandMapTileView: void drawOverMap(android.graphics.Canvas,android.graphics.RectF,android.graphics.RectF,net.osmand.plus.views.OsmandMapLayer$DrawSettings)>
	8: <net.osmand.plus.views.OsmBugsLayer: void onDraw(android.graphics.Canvas,android.graphics.RectF,android.graphics.RectF,net.osmand.plus.views.OsmandMapLayer$DrawSettings)>
	9: <net.osmand.plus.views.OsmBugsLayer: void requestToLoad(double,double,double,double,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivityActions$6: void onClick(android.content.DialogInterface,int)>
	3: <net.osmand.plus.activities.MapActivityActions: void updatePoiDb(int,double,double)>
	4: <net.osmand.plus.ResourceManager: net.osmand.plus.AmenityIndexRepositoryOdb getUpdatablePoiDb()>
	5: <net.osmand.plus.ResourceManager: boolean tryToOpenUpdatablePoiDb(java.io.File)>
	6: <net.osmand.plus.AmenityIndexRepositoryOdb: boolean initialize(net.osmand.IProgress,java.io.File)>
	7: <net.osmand.plus.BaseLocationIndexRepository: boolean initialize(net.osmand.IProgress,java.io.File,int,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivityActions$6: void onClick(android.content.DialogInterface,int)>
	3: <net.osmand.plus.activities.MapActivityActions: void updatePoiDb(int,double,double)>
	4: <net.osmand.plus.ResourceManager: net.osmand.plus.AmenityIndexRepositoryOdb getUpdatablePoiDb()>
	5: <net.osmand.plus.ResourceManager: boolean tryToOpenUpdatablePoiDb(java.io.File)>
	6: <net.osmand.plus.AmenityIndexRepositoryOdb: boolean initialize(net.osmand.IProgress,java.io.File)>
	7: <net.osmand.plus.BaseLocationIndexRepository: boolean initialize(net.osmand.IProgress,java.io.File,int,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.NavigationService dummyMainMethod_net_osmand_plus_NavigationService(android.content.Intent)>
	2: <net.osmand.plus.NavigationService: void onLocationChanged(android.location.Location)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.SettingsActivity dummyMainMethod_net_osmand_plus_activities_SettingsActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.SettingsActivity: boolean onPreferenceClick(android.preference.Preference)>
	3: <net.osmand.plus.activities.SavingTrackHelper: boolean hasDataToSave()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.activities.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.ResourceManager: void <init>(net.osmand.plus.activities.OsmandApplication)>
	3: <net.osmand.plus.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.activities.DownloadTilesDialog$5: void run()>
	5: <net.osmand.plus.ResourceManager: boolean tileExistOnFileSystem(java.lang.String,net.osmand.map.ITileSource,int,int,int)>
	6: <net.osmand.plus.SQLiteTileSource: boolean exists(int,int,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivityActions$14: void onClick(android.content.DialogInterface,int)>
	3: <net.osmand.plus.views.OsmandMapTileView: void refreshMap(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.search.SearchPOIActivity dummyMainMethod_net_osmand_plus_activities_search_SearchPOIActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.search.SearchPOIActivity: void onSensorChanged(android.hardware.SensorEvent)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.search.SearchPoiFilterActivity dummyMainMethod_net_osmand_plus_activities_search_SearchPoiFilterActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.search.SearchPoiFilterActivity: void onResume()>
	3: <net.osmand.plus.PoiFiltersHelper: java.util.List getUserDefinedPoiFilters()>
	4: <net.osmand.plus.PoiFiltersHelper$PoiFilterDbHelper: java.util.List getFilters()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.SettingsActivity dummyMainMethod_net_osmand_plus_activities_SettingsActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.SettingsActivity: boolean onPreferenceClick(android.preference.Preference)>
	3: <net.osmand.plus.activities.SavingTrackHelper: boolean hasDataToSave()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.search.SearchPoiFilterActivity dummyMainMethod_net_osmand_plus_activities_search_SearchPoiFilterActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.search.SearchPoiFilterActivity: void onResume()>
	3: <net.osmand.plus.PoiFiltersHelper: java.util.List getUserDefinedPoiFilters()>
	4: <net.osmand.plus.PoiFiltersHelper$PoiFilterDbHelper: java.util.List getFilters()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivity: void onResume()>
	3: <net.osmand.plus.activities.MapActivity: void setMapLinkedToLocation(boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivityActions$6: void onClick(android.content.DialogInterface,int)>
	3: <net.osmand.plus.activities.MapActivityActions: void updatePoiDb(int,double,double)>
	4: <net.osmand.plus.ResourceManager: net.osmand.plus.AmenityIndexRepositoryOdb getUpdatablePoiDb()>
	5: <net.osmand.plus.ResourceManager: boolean tryToOpenUpdatablePoiDb(java.io.File)>
	6: <net.osmand.plus.AmenityIndexRepositoryOdb: boolean initialize(net.osmand.IProgress,java.io.File)>
	7: <net.osmand.plus.BaseLocationIndexRepository: boolean initialize(net.osmand.IProgress,java.io.File,int,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.sqlite.SQLiteDatabase openDatabase(java.lang.String,android.database.sqlite.SQLiteDatabase$CursorFactory,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivityActions$5: void onClick(android.content.DialogInterface,int)>
	3: <net.osmand.plus.SQLiteTileSource: boolean couldBeDownloadedFromInternet()>
	4: <net.osmand.plus.SQLiteTileSource: android.database.sqlite.SQLiteDatabase getDatabase()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.sqlite.SQLiteDatabase openDatabase(java.lang.String,android.database.sqlite.SQLiteDatabase$CursorFactory,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivityActions$6: void onClick(android.content.DialogInterface,int)>
	3: <net.osmand.plus.activities.MapActivityActions: void updatePoiDb(int,double,double)>
	4: <net.osmand.plus.ResourceManager: net.osmand.plus.AmenityIndexRepositoryOdb getUpdatablePoiDb()>
	5: <net.osmand.plus.AmenityIndexRepositoryOdb: void createAmenityIndexRepository(java.io.File)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.activities.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.ResourceManager: void <init>(net.osmand.plus.activities.OsmandApplication)>
	3: <net.osmand.plus.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.views.OsmandMapTileView$1: void run()>
	5: <net.osmand.plus.views.OsmandMapTileView: void access$300(net.osmand.plus.views.OsmandMapTileView,boolean)>
	6: <net.osmand.plus.views.OsmandMapTileView: void refreshMapInternal(boolean)>
	7: <net.osmand.plus.views.OsmandMapTileView: void drawOverMap(android.graphics.Canvas,android.graphics.RectF,android.graphics.RectF,net.osmand.plus.views.OsmandMapLayer$DrawSettings)>
	8: <net.osmand.plus.views.MapControlsLayer: void onDraw(android.graphics.Canvas,android.graphics.RectF,android.graphics.RectF,net.osmand.plus.views.OsmandMapLayer$DrawSettings)>
	9: <net.osmand.plus.views.MapControlsLayer: void hideZoomLevelInTime()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.activities.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.ResourceManager: void <init>(net.osmand.plus.activities.OsmandApplication)>
	3: <net.osmand.plus.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.activities.SettingsActivity$7: void run()>
	5: <net.osmand.plus.activities.SavingTrackHelper: java.util.List saveDataToGpx()>
	6: <net.osmand.plus.activities.SavingTrackHelper: void collectDBTracks(android.database.sqlite.SQLiteDatabase,java.util.Map)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,java.lang.Runnable)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivity: void onResume()>
	3: <net.osmand.plus.activities.MapActivity: void showAndHideMapPosition()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.MapActivity dummyMainMethod_net_osmand_plus_activities_MapActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.MapActivityActions$6: void onClick(android.content.DialogInterface,int)>
	3: <net.osmand.plus.activities.MapActivityActions: void updatePoiDb(int,double,double)>
	4: <net.osmand.plus.ResourceManager: net.osmand.plus.AmenityIndexRepositoryOdb getUpdatablePoiDb()>
	5: <net.osmand.plus.ResourceManager: boolean tryToOpenUpdatablePoiDb(java.io.File)>
	6: <net.osmand.plus.AmenityIndexRepositoryOdb: boolean initialize(net.osmand.IProgress,java.io.File)>
	7: <net.osmand.plus.BaseLocationIndexRepository: boolean initialize(net.osmand.IProgress,java.io.File,int,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.search.SearchHistoryActivity dummyMainMethod_net_osmand_plus_activities_search_SearchHistoryActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.search.SearchHistoryActivity$1: void onClick(android.view.View)>
	3: <net.osmand.plus.activities.search.SearchHistoryHelper: java.util.List getHistoryEntries(android.content.Context)>
	4: <net.osmand.plus.activities.search.SearchHistoryHelper: net.osmand.plus.activities.search.SearchHistoryHelper$HistoryItemDBHelper checkLoadedEntries(android.content.Context)>
	5: <net.osmand.plus.activities.search.SearchHistoryHelper$HistoryItemDBHelper: java.util.List getEntries()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.sqlite.SQLiteDatabase openDatabase(java.lang.String,android.database.sqlite.SQLiteDatabase$CursorFactory,int)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: net.osmand.plus.activities.search.SearchBuildingByNameActivity dummyMainMethod_net_osmand_plus_activities_search_SearchBuildingByNameActivity(android.content.Intent)>
	2: <net.osmand.plus.activities.search.SearchByNameAbstractActivity: void onCreate(android.os.Bundle)>
	3: <net.osmand.plus.activities.LocalIndexesActivity$LoadLocalIndexDescriptionTask: java.lang.Object doInBackground(java.lang.Object[])>
	4: <net.osmand.plus.activities.LocalIndexesActivity$LoadLocalIndexDescriptionTask: net.osmand.plus.activities.LocalIndexHelper$LocalIndexInfo[] doInBackground(net.osmand.plus.activities.LocalIndexHelper$LocalIndexInfo[])>
	5: <net.osmand.plus.activities.LocalIndexHelper: void updateDescription(net.osmand.plus.activities.LocalIndexHelper$LocalIndexInfo)>
	6: <net.osmand.plus.activities.LocalIndexHelper: void checkPoiFileVersion(net.osmand.plus.activities.LocalIndexHelper$LocalIndexInfo,java.io.File)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <net.osmand.plus.activities.OsmandApplication: void onCreate()>
	2: <net.osmand.plus.ResourceManager: void <init>(net.osmand.plus.activities.OsmandApplication)>
	3: <net.osmand.plus.AsyncLoadingThread: void run()>
	4: <net.osmand.plus.AsyncLoadingThread$AmenityLoadRequest$1: void run()>
	5: <net.osmand.plus.AmenityIndexRepositoryOdb: void evaluateCachedAmenities(double,double,double,double,int,net.osmand.plus.PoiFilter,net.osmand.ResultMatcher)>
	6: <net.osmand.plus.AmenityIndexRepositoryOdb: java.util.List searchAmenities(int,int,int,int,int,net.osmand.plus.PoiFilter,java.util.List,net.osmand.ResultMatcher)>

Resource: java.util.Scanner
source method: getFileContent()
source file: AbstractResourceInstrumentationTestCase.java
Our analysis output:
Soot started on Sun May 03 03:22:16 EDT 2020
Soot finished on Sun May 03 03:23:39 EDT 2020
Soot has run for 1 min. 22 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.LogTrackableActivity dummyMainMethod_cgeo_geocaching_LogTrackableActivity(android.content.Intent)>
	2: <cgeo.geocaching.LogTrackableActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Trackable loadTrackable(java.lang.String)>
	4: <cgeo.geocaching.DataStore: cgeo.geocaching.Trackable createTrackableFromDatabaseContent(android.database.Cursor)>
	5: <cgeo.geocaching.DataStore: java.util.List loadLogs(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.SearchActivity dummyMainMethod_cgeo_geocaching_SearchActivity(android.content.Intent)>
	2: <cgeo.geocaching.SearchActivity$15: void onClick(android.view.View)>
	3: <cgeo.geocaching.maps.CGeoMap$LoadDetails: void run()>
	4: <cgeo.geocaching.Geocache: void storeCache(cgeo.geocaching.Geocache,java.lang.String,int,boolean,cgeo.geocaching.utils.CancellableHandler)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.sensors.GpsStatusProvider$1$1: void onGpsStatusChanged(int)>
	3: <rx.internal.operators.OperatorFinally$1: void onError(java.lang.Throwable)>
	4: <cgeo.geocaching.CacheDetailActivity$2: void call()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.sensors.GpsStatusProvider$1$1: void onGpsStatusChanged(int)>
	3: <rx.internal.operators.OperatorFinally$1: void onError(java.lang.Throwable)>
	4: <cgeo.geocaching.CacheDetailActivity$2: void call()>
	5: <cgeo.geocaching.Geocache: cgeo.geocaching.SearchResult searchByGeocode(java.lang.String,java.lang.String,int,boolean,cgeo.geocaching.utils.CancellableHandler)>
	6: <cgeo.geocaching.DataStore: boolean isThere(java.lang.String,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.search.SuggestionProvider dummyMainMethod_cgeo_geocaching_search_SuggestionProvider(android.content.Intent)>
	2: <cgeo.geocaching.search.SuggestionProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <cgeo.geocaching.search.SuggestionProvider: android.database.Cursor getSuggestions(java.lang.String)>
	4: <cgeo.geocaching.DataStore: android.database.Cursor findSuggestions(java.lang.String)>
	5: <cgeo.geocaching.DataStore: void findTrackables(android.database.MatrixCursor,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheListActivity dummyMainMethod_cgeo_geocaching_CacheListActivity(android.content.Intent)>
	2: <cgeo.geocaching.CacheListActivity: void onResume()>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.SearchResult getBatchOfStoredCaches(cgeo.geocaching.location.Geopoint,cgeo.geocaching.enumerations.CacheType,int)>
	4: <cgeo.geocaching.DataStore: java.util.Set loadBatchOfStoredGeocodes(cgeo.geocaching.location.Geopoint,cgeo.geocaching.enumerations.CacheType,int)>
	5: <cgeo.geocaching.DataStore: java.util.Collection queryToColl(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.util.Collection,rx.functions.Func1)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.CompassActivity: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <cgeo.geocaching.Geocache: void showHintToast(android.app.Activity)>
	4: <cgeo.geocaching.Geocache: java.lang.String getHint()>
	5: <cgeo.geocaching.Geocache: void initializeCacheTexts()>
	6: <cgeo.geocaching.DataStore: cgeo.geocaching.Geocache loadCacheTexts(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.sensors.GpsStatusProvider$1$1: void onGpsStatusChanged(int)>
	3: <rx.internal.operators.OperatorFinally$1: void onError(java.lang.Throwable)>
	4: <cgeo.geocaching.Geocache$3: void call()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.SearchActivity dummyMainMethod_cgeo_geocaching_SearchActivity(android.content.Intent)>
	2: <cgeo.geocaching.SearchActivity$15: void onClick(android.view.View)>
	3: <cgeo.geocaching.StaticMapsActivity$LoadMapsThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.CompassActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Geocache loadCache(java.lang.String,java.util.EnumSet)>
	4: <cgeo.geocaching.DataStore: java.util.Set loadCaches(java.util.Collection,java.util.EnumSet)>
	5: <cgeo.geocaching.DataStore: java.util.Set loadCachesFromGeocodes(java.util.Set,java.util.EnumSet)>
	6: <cgeo.geocaching.DataStore: java.util.List loadInventory(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.CompassActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Waypoint loadWaypoint(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.sensors.GpsStatusProvider$1$1: void onGpsStatusChanged(int)>
	3: <rx.internal.operators.OperatorDistinct$1: void onNext(java.lang.Object)>
	4: <cgeo.geocaching.SearchActivity$6: java.lang.Object call(java.lang.Object)>
	5: <cgeo.geocaching.SearchActivity$6: java.lang.String[] call(java.lang.String)>
	6: <cgeo.geocaching.DataStore: java.lang.String[] getSuggestionsGeocode(java.lang.String)>
	7: <cgeo.geocaching.DataStore: java.lang.String[] getSuggestions(java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.sensors.GpsStatusProvider$1$1: void onGpsStatusChanged(int)>
	3: <rx.internal.operators.OperatorFinally$1: void onError(java.lang.Throwable)>
	4: <cgeo.geocaching.CacheDetailActivity$2: void call()>
	5: <cgeo.geocaching.Geocache: cgeo.geocaching.SearchResult searchByGeocode(java.lang.String,java.lang.String,int,boolean,cgeo.geocaching.utils.CancellableHandler)>
	6: <cgeo.geocaching.DataStore: boolean isThere(java.lang.String,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.GpxFileListActivity dummyMainMethod_cgeo_geocaching_GpxFileListActivity(android.content.Intent)>
	2: <cgeo.geocaching.files.AbstractFileListActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.files.AbstractFileListActivity$SearchFilesThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.CompassActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Geocache loadCache(java.lang.String,java.util.EnumSet)>
	4: <cgeo.geocaching.DataStore: java.util.Set loadCaches(java.util.Collection,java.util.EnumSet)>
	5: <cgeo.geocaching.DataStore: java.util.Set loadCachesFromGeocodes(java.util.Set,java.util.EnumSet)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.search.SuggestionProvider dummyMainMethod_cgeo_geocaching_search_SuggestionProvider(android.content.Intent)>
	2: <cgeo.geocaching.search.SuggestionProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <cgeo.geocaching.search.SuggestionProvider: android.database.Cursor getSuggestions(java.lang.String)>
	4: <cgeo.geocaching.DataStore: android.database.Cursor findSuggestions(java.lang.String)>
	5: <cgeo.geocaching.DataStore: void findCaches(cgeo.geocaching.search.SearchSuggestionCursor,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheListActivity dummyMainMethod_cgeo_geocaching_CacheListActivity(android.content.Intent)>
	2: <cgeo.geocaching.CacheListActivity: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <cgeo.geocaching.CacheListActivity: void renameList()>
	4: <cgeo.geocaching.command.RenameListCommand: void execute()>
	5: <cgeo.geocaching.DataStore: cgeo.geocaching.list.StoredList getList(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.GpxFileListActivity dummyMainMethod_cgeo_geocaching_GpxFileListActivity(android.content.Intent)>
	2: <cgeo.geocaching.files.AbstractFileListActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.files.AbstractFileListActivity$SearchFilesThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.LogTrackableActivity dummyMainMethod_cgeo_geocaching_LogTrackableActivity(android.content.Intent)>
	2: <cgeo.geocaching.LogTrackableActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Trackable loadTrackable(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.GpxFileListActivity dummyMainMethod_cgeo_geocaching_GpxFileListActivity(android.content.Intent)>
	2: <cgeo.geocaching.files.AbstractFileListActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.files.AbstractFileListActivity$SearchFilesThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <cgeo.geocaching.CgeoApplication: void onCreate()>
	2: <cgeo.geocaching.DataStore: java.util.List getLists()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.GpxFileListActivity dummyMainMethod_cgeo_geocaching_GpxFileListActivity(android.content.Intent)>
	2: <cgeo.geocaching.files.AbstractFileListActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.files.AbstractFileListActivity$SearchFilesThread: void run()>
	4: <cgeo.geocaching.utils.FileUtils: void listDir(java.util.List,java.io.File,cgeo.geocaching.utils.FileUtils$FileSelector,android.os.Handler)>
	5: <cgeo.geocaching.utils.FileUtils: void listDirInternally(java.util.List,java.io.File,cgeo.geocaching.utils.FileUtils$FileSelector,android.os.Handler,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.SearchActivity dummyMainMethod_cgeo_geocaching_SearchActivity(android.content.Intent)>
	2: <cgeo.geocaching.SearchActivity$15: void onClick(android.view.View)>
	3: <cgeo.geocaching.EditWaypointActivity$LoadWaypointThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.CompassActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Geocache loadCache(java.lang.String,java.util.EnumSet)>
	4: <cgeo.geocaching.DataStore: java.util.Set loadCaches(java.util.Collection,java.util.EnumSet)>
	5: <cgeo.geocaching.DataStore: java.util.Set loadCachesFromGeocodes(java.util.Set,java.util.EnumSet)>
	6: <cgeo.geocaching.DataStore: java.util.Map loadLogCounts(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.LogCacheActivity dummyMainMethod_cgeo_geocaching_LogCacheActivity(android.content.Intent)>
	2: <cgeo.geocaching.LogCacheActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.LogEntry loadLogOffline(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.SearchActivity dummyMainMethod_cgeo_geocaching_SearchActivity(android.content.Intent)>
	2: <cgeo.geocaching.SearchActivity$15: void onClick(android.view.View)>
	3: <cgeo.geocaching.maps.CGeoMap$DoRunnable: void run()>
	4: <cgeo.geocaching.maps.CGeoMap$LoadRunnable: void runWithMap(cgeo.geocaching.maps.CGeoMap)>
	5: <cgeo.geocaching.maps.CGeoMap: void access$2600(cgeo.geocaching.maps.CGeoMap)>
	6: <cgeo.geocaching.maps.CGeoMap: void doLoadRun()>
	7: <cgeo.geocaching.DataStore: java.util.Set loadWaypoints(cgeo.geocaching.location.Viewport,boolean,boolean,cgeo.geocaching.enumerations.CacheType)>

Resource: java.util.Scanner
source method: getRawResourceString()
source file: AboutActivity.java
Our analysis output:
Soot started on Sun May 03 03:26:29 EDT 2020
Soot finished on Sun May 03 03:27:34 EDT 2020
Soot has run for 1 min. 5 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheListActivity dummyMainMethod_cgeo_geocaching_CacheListActivity(android.content.Intent)>
	2: <cgeo.geocaching.activity.OAuthAuthorizationActivity$StartListener: void onClick(android.view.View)>
	3: <rx.schedulers.ImmediateScheduler$InnerImmediateScheduler: rx.Subscription schedule(rx.functions.Action0)>
	4: <cgeo.geocaching.CacheDetailActivity$13: void call()>
	5: <cgeo.geocaching.EditWaypointActivity$LoadWaypointThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.LogTrackableActivity dummyMainMethod_cgeo_geocaching_LogTrackableActivity(android.content.Intent)>
	2: <cgeo.geocaching.LogTrackableActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Trackable loadTrackable(java.lang.String)>
	4: <cgeo.geocaching.DataStore: cgeo.geocaching.Trackable createTrackableFromDatabaseContent(android.database.Cursor)>
	5: <cgeo.geocaching.DataStore: java.util.List loadLogs(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheListActivity dummyMainMethod_cgeo_geocaching_CacheListActivity(android.content.Intent)>
	2: <cgeo.geocaching.activity.OAuthAuthorizationActivity$StartListener: void onClick(android.view.View)>
	3: <rx.schedulers.ImmediateScheduler$InnerImmediateScheduler: rx.Subscription schedule(rx.functions.Action0)>
	4: <cgeo.geocaching.Geocache$3: void call()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.CompassActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Geocache loadCache(java.lang.String,java.util.EnumSet)>
	4: <cgeo.geocaching.DataStore: java.util.Set loadCaches(java.util.Collection,java.util.EnumSet)>
	5: <cgeo.geocaching.DataStore: java.util.Set loadCachesFromGeocodes(java.util.Set,java.util.EnumSet)>
	6: <cgeo.geocaching.DataStore: java.util.Map loadLogCounts(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.search.SuggestionProvider dummyMainMethod_cgeo_geocaching_search_SuggestionProvider(android.content.Intent)>
	2: <cgeo.geocaching.search.SuggestionProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <cgeo.geocaching.search.SuggestionProvider: android.database.Cursor getSuggestions(java.lang.String)>
	4: <cgeo.geocaching.DataStore: android.database.Cursor findSuggestions(java.lang.String)>
	5: <cgeo.geocaching.DataStore: void findCaches(cgeo.geocaching.search.SearchSuggestionCursor,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.search.SuggestionProvider dummyMainMethod_cgeo_geocaching_search_SuggestionProvider(android.content.Intent)>
	2: <cgeo.geocaching.search.SuggestionProvider: android.database.Cursor query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)>
	3: <cgeo.geocaching.search.SuggestionProvider: android.database.Cursor getSuggestions(java.lang.String)>
	4: <cgeo.geocaching.DataStore: android.database.Cursor findSuggestions(java.lang.String)>
	5: <cgeo.geocaching.DataStore: void findTrackables(android.database.MatrixCursor,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.LogTrackableActivity dummyMainMethod_cgeo_geocaching_LogTrackableActivity(android.content.Intent)>
	2: <cgeo.geocaching.LogTrackableActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Trackable loadTrackable(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.GpxFileListActivity dummyMainMethod_cgeo_geocaching_GpxFileListActivity(android.content.Intent)>
	2: <cgeo.geocaching.files.AbstractFileListActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.files.AbstractFileListActivity$SearchFilesThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheListActivity dummyMainMethod_cgeo_geocaching_CacheListActivity(android.content.Intent)>
	2: <cgeo.geocaching.activity.OAuthAuthorizationActivity$StartListener: void onClick(android.view.View)>
	3: <rx.schedulers.ImmediateScheduler$InnerImmediateScheduler: rx.Subscription schedule(rx.functions.Action0)>
	4: <cgeo.geocaching.Geocache$4: void call()>
	5: <cgeo.geocaching.Geocache: void refreshSynchronous(cgeo.geocaching.utils.CancellableHandler)>
	6: <cgeo.geocaching.Geocache: void storeCache(cgeo.geocaching.Geocache,java.lang.String,int,boolean,cgeo.geocaching.utils.CancellableHandler)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheListActivity dummyMainMethod_cgeo_geocaching_CacheListActivity(android.content.Intent)>
	2: <cgeo.geocaching.CacheListActivity: void onResume()>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.SearchResult getBatchOfStoredCaches(cgeo.geocaching.location.Geopoint,cgeo.geocaching.enumerations.CacheType,int)>
	4: <cgeo.geocaching.DataStore: java.util.Set loadBatchOfStoredGeocodes(cgeo.geocaching.location.Geopoint,cgeo.geocaching.enumerations.CacheType,int)>
	5: <cgeo.geocaching.DataStore: java.util.Collection queryToColl(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.util.Collection,rx.functions.Func1)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.LogCacheActivity dummyMainMethod_cgeo_geocaching_LogCacheActivity(android.content.Intent)>
	2: <cgeo.geocaching.LogCacheActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.LogEntry loadLogOffline(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.GpxFileListActivity dummyMainMethod_cgeo_geocaching_GpxFileListActivity(android.content.Intent)>
	2: <cgeo.geocaching.files.AbstractFileListActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.files.AbstractFileListActivity$SearchFilesThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheListActivity dummyMainMethod_cgeo_geocaching_CacheListActivity(android.content.Intent)>
	2: <cgeo.geocaching.activity.OAuthAuthorizationActivity$StartListener: void onClick(android.view.View)>
	3: <rx.schedulers.ImmediateScheduler$InnerImmediateScheduler: rx.Subscription schedule(rx.functions.Action0)>
	4: <cgeo.geocaching.CacheDetailActivity$2: void call()>
	5: <cgeo.geocaching.Geocache: cgeo.geocaching.SearchResult searchByGeocode(java.lang.String,java.lang.String,int,boolean,cgeo.geocaching.utils.CancellableHandler)>
	6: <cgeo.geocaching.DataStore: boolean isThere(java.lang.String,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.GpxFileListActivity dummyMainMethod_cgeo_geocaching_GpxFileListActivity(android.content.Intent)>
	2: <cgeo.geocaching.files.AbstractFileListActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.files.AbstractFileListActivity$SearchFilesThread: void run()>
	4: <cgeo.geocaching.utils.FileUtils: void listDir(java.util.List,java.io.File,cgeo.geocaching.utils.FileUtils$FileSelector,android.os.Handler)>
	5: <cgeo.geocaching.utils.FileUtils: void listDirInternally(java.util.List,java.io.File,cgeo.geocaching.utils.FileUtils$FileSelector,android.os.Handler,int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain(android.os.Handler,int,java.lang.Object)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.GpxFileListActivity dummyMainMethod_cgeo_geocaching_GpxFileListActivity(android.content.Intent)>
	2: <cgeo.geocaching.files.AbstractFileListActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.files.AbstractFileListActivity$SearchFilesThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheListActivity dummyMainMethod_cgeo_geocaching_CacheListActivity(android.content.Intent)>
	2: <cgeo.geocaching.activity.OAuthAuthorizationActivity$StartListener: void onClick(android.view.View)>
	3: <rx.schedulers.ImmediateScheduler$InnerImmediateScheduler: rx.Subscription schedule(rx.functions.Action0)>
	4: <cgeo.geocaching.CacheDetailActivity$2: void call()>
	5: <cgeo.geocaching.Geocache: cgeo.geocaching.SearchResult searchByGeocode(java.lang.String,java.lang.String,int,boolean,cgeo.geocaching.utils.CancellableHandler)>
	6: <cgeo.geocaching.DataStore: boolean isThere(java.lang.String,java.lang.String,boolean)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.CompassActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Geocache loadCache(java.lang.String,java.util.EnumSet)>
	4: <cgeo.geocaching.DataStore: java.util.Set loadCaches(java.util.Collection,java.util.EnumSet)>
	5: <cgeo.geocaching.DataStore: java.util.Set loadCachesFromGeocodes(java.util.Set,java.util.EnumSet)>
	6: <cgeo.geocaching.DataStore: java.util.List loadInventory(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheListActivity dummyMainMethod_cgeo_geocaching_CacheListActivity(android.content.Intent)>
	2: <rx.android.content.OnSubscribeSharedPreferenceChange$1: void onSharedPreferenceChanged(android.content.SharedPreferences,java.lang.String)>
	3: <rx.internal.operators.OperatorDistinct$1: void onNext(java.lang.Object)>
	4: <cgeo.geocaching.SearchActivity$6: java.lang.Object call(java.lang.Object)>
	5: <cgeo.geocaching.SearchActivity$6: java.lang.String[] call(java.lang.String)>
	6: <cgeo.geocaching.DataStore: java.lang.String[] getSuggestionsGeocode(java.lang.String)>
	7: <cgeo.geocaching.DataStore: java.lang.String[] getSuggestions(java.lang.String,java.lang.String,java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheListActivity dummyMainMethod_cgeo_geocaching_CacheListActivity(android.content.Intent)>
	2: <cgeo.geocaching.activity.OAuthAuthorizationActivity$StartListener: void onClick(android.view.View)>
	3: <rx.schedulers.ImmediateScheduler$InnerImmediateScheduler: rx.Subscription schedule(rx.functions.Action0)>
	4: <cgeo.geocaching.CacheDetailActivity$2: void call()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CacheListActivity dummyMainMethod_cgeo_geocaching_CacheListActivity(android.content.Intent)>
	2: <cgeo.geocaching.CacheListActivity: void onActivityResult(int,int,android.content.Intent)>
	3: <cgeo.geocaching.CacheListActivity: void refreshCurrentList()>
	4: <cgeo.geocaching.CacheListActivity: void switchListById(int)>
	5: <cgeo.geocaching.DataStore: cgeo.geocaching.list.StoredList getList(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.os.Message: android.os.Message obtain()>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.StaticMapsActivity_ dummyMainMethod_cgeo_geocaching_StaticMapsActivity__(android.content.Intent)>
	2: <cgeo.geocaching.StaticMapsActivity_: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.StaticMapsActivity: void onCreate(android.os.Bundle)>
	4: <cgeo.geocaching.StaticMapsActivity$LoadMapsThread: void run()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.CompassActivity: boolean onOptionsItemSelected(android.view.MenuItem)>
	3: <cgeo.geocaching.Geocache: void showHintToast(android.app.Activity)>
	4: <cgeo.geocaching.Geocache: java.lang.String getHint()>
	5: <cgeo.geocaching.Geocache: void initializeCacheTexts()>
	6: <cgeo.geocaching.DataStore: cgeo.geocaching.Geocache loadCacheTexts(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.CompassActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Waypoint loadWaypoint(int)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor rawQuery(java.lang.String,java.lang.String[])>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: cgeo.geocaching.CompassActivity dummyMainMethod_cgeo_geocaching_CompassActivity(android.content.Intent)>
	2: <cgeo.geocaching.CompassActivity: void onCreate(android.os.Bundle)>
	3: <cgeo.geocaching.DataStore: cgeo.geocaching.Geocache loadCache(java.lang.String,java.util.EnumSet)>
	4: <cgeo.geocaching.DataStore: java.util.Set loadCaches(java.util.Collection,java.util.EnumSet)>
	5: <cgeo.geocaching.DataStore: java.util.Set loadCachesFromGeocodes(java.util.Set,java.util.EnumSet)>

Resource: org.apache.http.impl.client.DefaultHttpClient
source method: doInBackground() @line 142
source file: AccountActivity.java
Our analysis output:
Soot started on Sun May 03 03:28:50 EDT 2020
Soot finished on Sun May 03 03:28:55 EDT 2020
Soot has run for 0 min. 5 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Account accountFromDb(android.content.Context,java.lang.String,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchTransactions(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Bank bankFromDb(long,android.content.Context,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor getBank(long)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor getBank(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.MainActivity dummyMainMethod_com_liato_bankdroid_MainActivity(android.content.Intent)>
	2: <com.liato.bankdroid.MainActivity$PopupMenu$2: void onClick(android.content.DialogInterface,int)>
	3: <com.liato.bankdroid.MainActivity: void refreshView()>
	4: <com.liato.bankdroid.BankFactory: java.util.ArrayList banksFromDb(android.content.Context,boolean)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchBanks()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Bank bankFromDb(long,android.content.Context,boolean)>
	4: <com.liato.bankdroid.BankFactory: java.util.ArrayList accountsFromDb(android.content.Context,long)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchAccounts(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Account accountFromDb(android.content.Context,java.lang.String,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor getAccount(java.lang.String)>

Resource: org.apache.http.impl.client.DefaultHttpClient
source method: doInBackground() @line 73
source file: AutoRefreshService.java
Our analysis output:
Soot started on Sun May 03 03:29:00 EDT 2020
Soot finished on Sun May 03 03:29:05 EDT 2020
Soot has run for 0 min. 5 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Bank bankFromDb(long,android.content.Context,boolean)>
	4: <com.liato.bankdroid.BankFactory: java.util.ArrayList accountsFromDb(android.content.Context,long)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchAccounts(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.MainActivity dummyMainMethod_com_liato_bankdroid_MainActivity(android.content.Intent)>
	2: <com.liato.bankdroid.MainActivity$PopupMenu$2: void onClick(android.content.DialogInterface,int)>
	3: <com.liato.bankdroid.MainActivity: void refreshView()>
	4: <com.liato.bankdroid.BankFactory: java.util.ArrayList banksFromDb(android.content.Context,boolean)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchBanks()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Account accountFromDb(android.content.Context,java.lang.String,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchTransactions(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Bank bankFromDb(long,android.content.Context,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor getBank(long)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor getBank(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Account accountFromDb(android.content.Context,java.lang.String,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor getAccount(java.lang.String)>

Resource: org.apache.http.impl.client.DefaultHttpClient
source method: doInBackground() @line 203
source file: BankdroidWidgetProvider.java
Our analysis output:
Soot started on Sun May 03 03:29:11 EDT 2020
Soot finished on Sun May 03 03:29:17 EDT 2020
Soot has run for 0 min. 5 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.MainActivity dummyMainMethod_com_liato_bankdroid_MainActivity(android.content.Intent)>
	2: <com.liato.bankdroid.MainActivity$PopupMenu$2: void onClick(android.content.DialogInterface,int)>
	3: <com.liato.bankdroid.MainActivity: void refreshView()>
	4: <com.liato.bankdroid.BankFactory: java.util.ArrayList banksFromDb(android.content.Context,boolean)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchBanks()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.AccountActivity dummyMainMethod_com_liato_bankdroid_AccountActivity(android.content.Intent)>
	2: <com.liato.bankdroid.AccountActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Bank bankFromDb(long,android.content.Context,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor getBank(long)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor getBank(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.AccountActivity dummyMainMethod_com_liato_bankdroid_AccountActivity(android.content.Intent)>
	2: <com.liato.bankdroid.AccountActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Bank bankFromDb(long,android.content.Context,boolean)>
	4: <com.liato.bankdroid.BankFactory: java.util.ArrayList accountsFromDb(android.content.Context,long)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchAccounts(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Account accountFromDb(android.content.Context,java.lang.String,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor getAccount(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Account accountFromDb(android.content.Context,java.lang.String,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchTransactions(java.lang.String)>

Resource: org.apache.http.impl.client.DefaultHttpClient
source method: doInBackground() @line 36
source file: DataRetrieverTask.java
Our analysis output:
Soot started on Sun May 03 03:29:23 EDT 2020
Soot finished on Sun May 03 03:29:28 EDT 2020
Soot has run for 0 min. 4 sec.
Starting analysis...
Analysis finished.
==========================(Resources)==============================
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Bank bankFromDb(long,android.content.Context,boolean)>
	4: <com.liato.bankdroid.BankFactory: java.util.ArrayList accountsFromDb(android.content.Context,long)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchAccounts(long)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.MainActivity dummyMainMethod_com_liato_bankdroid_MainActivity(android.content.Intent)>
	2: <com.liato.bankdroid.MainActivity$PopupMenu$2: void onClick(android.content.DialogInterface,int)>
	3: <com.liato.bankdroid.MainActivity: void refreshView()>
	4: <com.liato.bankdroid.BankFactory: java.util.ArrayList banksFromDb(android.content.Context,boolean)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchBanks()>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Account accountFromDb(android.content.Context,java.lang.String,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor fetchTransactions(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Bank bankFromDb(long,android.content.Context,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor getBank(long)>
	5: <com.liato.bankdroid.DBAdapter: android.database.Cursor getBank(java.lang.String)>
PATH NOT CLOSED (POTENTIAL LEAK):
SOURCE:
	<android.database.sqlite.SQLiteDatabase: android.database.Cursor query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)>
PATH TO SOURCE METHOD:
	0: <dummyMainClass: void dummyMainMethod(java.lang.String[])>
	1: <dummyMainClass: com.liato.bankdroid.TransactionsActivity dummyMainMethod_com_liato_bankdroid_TransactionsActivity(android.content.Intent)>
	2: <com.liato.bankdroid.TransactionsActivity: void onCreate(android.os.Bundle)>
	3: <com.liato.bankdroid.BankFactory: com.liato.bankdroid.Account accountFromDb(android.content.Context,java.lang.String,boolean)>
	4: <com.liato.bankdroid.DBAdapter: android.database.Cursor getAccount(java.lang.String)>

{'Owncloud-rev-1b628540c92.apk', 'CycleStreets-rev-1c9a3064f4.apk', 'Wordpress-rev-4252d9ea21.apk', 'Hacker News-rev-3491bef7d1.apk', 'VLC-rev-10b0263c57.apk', 'Cgeo-rev-42e4da93bc.apk', 'Owncloud-rev-74c29e1ce1.apk', 'Wordpress-rev-5eaf6cc07f.apk', 'CallMeter-rev-b0c2afad23.apk', 'Wordpress-rev-58273a4124.apk', 'CSipSimple-rev-eac20442bb.apk', 'CSipSimple-rev-88d62bc951.apk', 'K-9 Mail-rev-3171ee969f.apk', 'Xabber-rev-872233a339.apk', 'AnySoftKeyboard-rev-fa32c64565.apk', 'K-9 Mail-rev-602ce7be99.apk', 'FBReaderJ-rev-c3d00e2dd.apk', 'Surespot-rev-bc2dcf47d8.apk', 'VLC-rev-960052e069.apk', 'SMSDroid-rev-3aa0d074ae.apk', 'K-9 Mail-rev-e3f6561008.apk', 'Surespot-rev-9ed3180387.apk', 'Osmand-rev-681f6a27e0.apk', 'ConnectBot-rev-1a2f49f29c.apk', 'ConnectBot-rev-34a2c4a660.apk', 'Quran for Android-rev-058a1256c4.apk', 'IRCCloud-rev-d7a441e3a6.apk', 'ChatSecure-rev-f4d4acc464.apk', 'Ushahidi-rev-d578c72309.apk', 'IRCCloud-rev-1ab8ba96f6.apk', 'Owncloud-rev-10e4373bcf.apk', 'AnkiDroid-rev-eca3100494.apk', 'CallMeter-rev-4c5f567e81.apk', 'Cgeo-rev-253c271b34.apk', 'Cgeo-rev-baf51975fa.apk', 'ChatSecure-rev-187adca1b9.apk', 'FBReaderJ-rev-536aa6fafa.apk', 'CallMeter-rev-10729ea13b.apk', 'VLC-rev-7573d27b67.apk', 'K-9 Mail-rev-dfa97cd878.apk', 'VLC-rev-dfdc88d64f.apk', 'Osmand-rev-99ba127f50.apk', 'Bitcoin-wallet-rev-c33b6525df.apk', 'APG-rev-727783dd00.apk', 'Zxing-rev-56644b1af2.apk', 'Owncloud-rev-f12956fe2a.apk', 'Wordpress-rev-035f127679.apk', 'Xabber-rev-926f4ca93e.apk', 'ChatSecure-rev-cbbbaf8e2f.apk', 'Wordpress-rev-a1a2c7f761.apk', 'FBReaderJ-rev-39b312b0f2.apk', 'OsmDroid-rev-30135da42f.apk', 'AnkiDroid-rev-197eefad0b.apk', 'CSipSimple-rev-1baa62c1a7.apk', 'Wordpress-rev-50bf44a3b2.apk', 'CallMeter-rev-a6688d9fbc.apk', 'K-9 Mail-rev-71a8ffc2b5.apk', 'Open-GPSTracker-rev-8ac7905a5a.apk', 'AnkiDroid-rev-f355183d84.apk', 'Wordpress-rev-4c554fd6c0.apk', 'K-9 Mail-rev-39aa577651.apk', 'Google Authenticator-rev-f7dee7574d.apk', 'AnkiDroid-rev-e87690da8f.apk', 'Owncloud-rev-35ace0b973.apk', 'K-9 Mail-rev-1596ddfaab.apk', 'ChatSecure-rev-d1b67f7a9a.apk', 'IRCCloud-rev-a4f427982f.apk', 'K-9 Mail-rev-e6132286a0.apk', 'CSipSimple-rev-a94f7336d0.apk', 'AnySoftKeyboard-rev-4b7d714258.apk', 'Cgeo-rev-c05dbd6fdf.apk', 'K-9 Mail-rev-6cd52c123c.apk', 'Quran for Android-rev-f5c4be3db0.apk', 'Ushahidi-rev-9d0aa75b84.apk', 'K-9 Mail-rev-057b316bcb.apk', 'CSipSimple-rev-d50021f164.apk', 'ChatSecure-rev-ba1ae18409.apk', 'Osmand-rev-053abea161.apk', 'Bankdroid-rev-096d565e3d.apk', 'Osmand-rev-50249440e2.apk', 'Transdroid-rev-f82ba6e12b.apk', 'AnkiDroid-rev-3725ce7582.apk', 'Quran for Android-rev-185f5a517d.apk', 'AnkiDroid-rev-9235be8331.apk', 'Cgeo-rev-e2c320b5f9.apk', 'K-9 Mail-rev-03dd89b3f9.apk', 'Osmand-rev-266e62c459.apk', 'FBReaderJ-rev-0466e8d1a6.apk', 'ChatSecure-rev-788594fe58.apk', 'AnySoftKeyboard-rev-b832671708.apk', 'AnkiDroid-rev-3e9ddc7eca.apk', 'Bitcoin-wallet-rev-e05dfb7fae.apk', 'ChatSecure-rev-e6dc310f3e.apk', 'Ushahidi-rev-5750c01198.apk', 'ChatSecure-rev-685de9286f.apk', 'AnkiDroid-rev-362fa48a25.apk', 'APG-rev-300fd8e0f2.apk', 'Zxing-rev-35e13989af.apk', 'Wordpress-rev-657bf0c2cf.apk', 'OsmDroid-rev-f6a2e34592.apk', 'ConnectBot-rev-76c4f80e47.apk', 'K-9 Mail-rev-0a07250417.apk', 'VLC-rev-8eb52cba71.apk', 'Bitcoin-wallet-rev-6388d3c75e.apk', 'AnySoftKeyboard-rev-6f539583a8.apk', 'Open-GPSTracker-rev-ba72b95903.apk', 'Surespot-rev-ff2c80d15b.apk', 'Osmand-rev-28f3b74069.apk', 'IRCCloud-rev-b8eddb5746.apk', 'ConnectBot-rev-2cecc0403f.apk', 'CallMeter-rev-9500b4240c.apk', 'Wordpress-rev-480fcb3c4d.apk', 'Cgeo-rev-8987674ab4.apk', 'K-9 Mail-rev-378acbd313.apk', 'CallMeter-rev-aed879c8a6.apk', 'Quran for Android-rev-a01cd99835.apk', 'Wordpress-rev-003f846a5b.apk', 'AnkiDroid-rev-f1f1161502.apk', 'VLC-rev-c446cc9877.apk', 'CSipSimple-rev-0a2a1f1d37.apk', 'CallMeter-rev-4fccc09ae9.apk', 'VLC-rev-14b18bc27f.apk', 'Wordpress-rev-42de8a232c.apk', 'ChatSecure-rev-dec89faee2.apk', 'Osmand-rev-2aa87f74cc.apk', 'AnkiDroid-rev-cfe6d83f85.apk', 'Bankdroid-rev-1747b81da8.apk', 'Quran for Android-rev-a632e803c5.apk', 'ChatSecure-rev-4482c3e66d.apk', 'SMSDroid-rev-01218844ba.apk', 'CallMeter-rev-14f44523a5.apk', 'K-9 Mail-rev-406aae6e61.apk', 'Bankdroid-rev-bf136c7b0a.apk', 'Osmand-rev-88ea34e8c0.apk', 'IRCCloud-rev-7d21b09aaa.apk', 'ChatSecure-rev-446ad5c623.apk', 'Wordpress-rev-4b1d15cb26.apk', 'Quran for Android-rev-121cd5803b.apk', 'K-9 Mail-rev-12d1097a24.apk', 'CSipSimple-rev-bf79346fcb.apk', 'ChatSecure-rev-89031f61f6.apk', 'Terminal-rev-7ede276096.apk', 'Bankdroid-rev-2b0345b5c2.apk', 'ChatSecure-rev-f2ae50bcba.apk', 'VLC-rev-f106951756.apk', 'ChatSecure-rev-975f1c3511.apk', 'K-9 Mail-rev-3253466f14.apk', 'VLC-rev-1cc3fc69d8.apk', 'ChatSecure-rev-b0a731606d.apk', 'OSMTracker-rev-f66282f5c7.apk', 'ConnectBot-rev-2dfa7ae033.apk', 'APG-rev-a45aaa2277.apk', 'SipDroid-rev-201646635a.apk', 'AnkiDroid-rev-fc102fb69f.apk', 'Osmand-rev-9d967a96ae.apk', 'K-9 Mail-rev-20eab9c812.apk', 'IRCCloud-rev-5f8ca597a5.apk', 'Cgeo-rev-1f1b81c531.apk', 'Osmand-rev-cfbfa188cc.apk', 'Wordpress-rev-380064faa9.apk', 'ChatSecure-rev-0e7026d7cf.apk', 'FBReaderJ-rev-59187733c9.apk', 'AnkiDroid-rev-8315e1fa10.apk', 'Ushahidi-rev-fad8f4227b.apk', 'Osmand-rev-2da1458999.apk', 'Quran for Android-rev-1f6d216dc8.apk', 'K-9 Mail-rev-fcabb7395d.apk', 'AnkiDroid-rev-126a6fdb67.apk', 'VLC-rev-52c095c0b8.apk', 'AnkiDroid-rev-48c627368c.apk', 'K-9 Mail-rev-acd18291f2.apk'}

Process finished with exit code 0
